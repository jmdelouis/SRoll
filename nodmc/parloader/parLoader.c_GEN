/******************************************************************************
 * "__TAG__parLoader.c"
 * 
 * This file has been generated by the ParLoader.
 *
 * This file is able to read a text parameter file (key=value) and load the
 * corresponding content to the specified structure.
 *
 * author:  Christan Madsen
 * date:    2015-04-03 (initial)
 * version: BETA
 *****************************************************************************/

#include <stdbool.h>
#include <stdlib.h>
#include <ctype.h>
#include <errno.h>
#include <string.h>
#include <Python.h>

#include "__TAG__parLoader.h"
#include "no_dmc_util.h" // Make use of several utils from the NO_DMC_LIB
//#include "no_dmc_debug.h"


// *** START INCLUDE GUARD ****************************************************
// The following is common to all parLoader 'instance'.

#ifndef _PARLOADER_C_GUARD
#define _PARLOADER_C_GUARD


// TODO to see if need to be set as PIOSTRING MAX LENGTH...
#define MAX_LINE_LENGTH 256

// This is the prefix used in parameter file to indicate the list number element
#define PARAM_PREFIX_LIST "number_of_"


// This structure allow to store parameters information
typedef struct {
  char *name;     // name of the parameter
  bool isList;    // 'false' for standard and 'true' for list
  bool mandatory; // 'true' if param presence is mandatory, 'false' otherwise. Note that in case of 'false' we have to update the flag value.
  bool found;     // to remember if we found the param
//  char *type;     // data type of the parameter : will be used for convertion from string to value. Type can be any of those listed in no_dmc_piolib_type_def.h
} paramDef;


//plip
/* ---------------------------------------------------------------------------------*/
int getListSize_old(PyObject * params,char * name){
  /* Function that return the size of list via list name */
  //name = "number_of_"+name
  //name = strcat("number_of_",name);
  int sizeNewName = strlen(PARAM_PREFIX_LIST)+ strlen( name ) + 1;
  char * newName = (char *) malloc( sizeNewName );

  strcpy(newName,PARAM_PREFIX_LIST);
  strcat(newName,name);

  int tmp_value = (int) PyLong_AsLong(PyDict_GetItemString(params,newName));

  free(newName);

  return tmp_value;
}
/* ---------------------------------------------------------------------------------*/
int getListSize(PyObject * params,char * name){
  /* Function that return the size of list via list name */
  //name = "number_of_"+name
  //name = strcat("number_of_",name);

  int size;
  PyObject * tmp = PyDict_GetItemString(params,name);
  size=(int)PyList_Size(tmp);


  return size;
}

/* ---------------------------------------------------------------------------------*/
int testParam(PyObject * params,char * name){
 /* test if name is in parameters list with keywords form PyObject =>params
  Params needed :
    name = keyword
  */
  PyObject * tmp_value=PyDict_GetItemString(params,name);
  if(tmp_value == NULL) return 1;
  return 0;
}
/* ---------------------------------------------------------------------------------*/
void strip_ext(char *fname)
{
    char *end = fname + strlen(fname);

    while (end > fname && *end != '.') {
        --end;
    }

    if (end > fname) {
        *end = '\0';
    }
}
/* ---------------------------------------------------------------------------------*/
PyObject * load_PyParams(char* path){
    /* Load python parameters form file gived in parameters path */    

    // init variables
    PyObject *pName, *pModule, *pDict, *pFunc;
    PyObject * params;


    // Initialize the Python Interpreter
    Py_Initialize();

    strip_ext(path);
    
    //add current path to python
    PyRun_SimpleString("import sys");
    PyRun_SimpleString("import os");
    PyRun_SimpleString("sys.path.append(os.getcwd())");

    // Build the name object
    pName = PyUnicode_FromString(path);
    
    // Load the module object
    pModule = PyImport_Import(pName);

    if ((pModule = PyImport_Import(pName)) == NULL) {
      fprintf(stderr,"Error: PyImport_Import\n");
      exit(0);
    }
 
    // pDict is a borrowed reference 
    pDict = PyModule_GetDict(pModule);

    // pFunc is also a borrowed reference 
    pFunc = PyDict_GetItemString(pDict, "main");

    if (PyCallable_Check(pFunc)){
        params = PyObject_CallObject(pFunc, NULL);
        
    }else{
        PyErr_Print();
        exit(0);
    }

    
 return params;
  
}
/* ---------------------------------------------------------------------------------*/
PyObject * getParam(PyObject * params,char * pName){
  /* get parameters with keywords form PyObject =>params 
  Params needed : 
    pName = keyword
  */ 
  
  PyObject * tmp_value=PyDict_GetItemString(params,pName);
  
  return tmp_value;

}
/* ---------------------------------------------------------------------------------*/
PyObject * getItemParam(PyObject * params,char * pName,int index){
  /* get item from parameter with keywords and index form PyObject =>params 
  Params needed : 
    pName = keyword
    index = index of the return param
   */  

  PyObject * tmp_value=PyDict_GetItemString(params,pName);

  tmp_value =PyList_GetItem(tmp_value,index);
  return tmp_value;

}
/* ---------------------------------------------------------------------------------*/



/**
 * Extract PIODOUBLE from the specified string value.
 */
PIODOUBLE myRead_PIODOUBLE(PIOSTRING value) {
  char *endptr;
  PIODOUBLE tmpval;
  
  tmpval = strtod(value, &endptr);

  // Ensure that all chars are converted to value, otherwise act like if it was an error.
  if (*endptr != '\0') {
    errno = EILSEQ;
  }

  return tmpval;
}

/**
 * Extract PIOLONG from the specified string value.
 */
PIOLONG myRead_PIOLONG(PIOSTRING value) {
  char *endptr;
  PIOLONG tmpval;
  
  tmpval = strtol(value, &endptr, 10);

  // Ensure that all chars are converted to value, otherwise act like if it was an error.
  if (*endptr != '\0') {
    errno = EILSEQ;
  }

  return tmpval;
}

/**
 * Extract PIOFLOAT from the specified string value.
 */
PIOFLOAT myRead_PIOFLOAT(PIOSTRING value) {
  char *endptr;
  PIOFLOAT tmpval;

  tmpval = strtof(value, &endptr);

  // Ensure that all chars are converted to value, otherwise act like if it was an error.
  if (*endptr != '\0') {
    errno = EILSEQ;
  }

  return tmpval;
}

/**
 * Extract PIOINT from the specified string value.
 */
PIOINT myRead_PIOINT(PIOSTRING value) {
  char *endptr;
  PIOINT tmpval;

  tmpval = strtol(value, &endptr, 10);

  // Ensure that all chars are converted to value, otherwise act like if it was an error.
  if (*endptr != '\0') {
    errno = EILSEQ;
  }

  return tmpval;
}

// Not that there is no myRead_PIOSTRING() since the conversion is unecessary!

/**
 * Allow to retrieve the corresponding paramDef (if any) regarding the name pass in arg.
 */
paramDef *getParamDef(char *name, paramDef paramDef_list[], int paramDef_list_size) {

  int i;
  for (i = 0; i < paramDef_list_size; i++) {
    if (strcmp(name, paramDef_list[i].name) == 0) {
      return &paramDef_list[i];
    }
  }
  
  fprintf(stderr, "ERROR: Invalid parameter '%s': not defined in struct header file!\n", name);
  return NULL;
}

#endif
// *** END INCLUDE GUARD ******************************************************


// Auto generated by the python script
__AUTO_GEN_PARAM_DEF_FULL_LIST__


/**
 * Allow to update (ie. store) the parameter value(s) in the structure.
 *
 * @param list_size the size of the list (if any) otherwise the value is ignored.
 */
int __TAG__updateParam(__TAG__parContent *param, char *name, PIOSTRING *value, PIOLONG list_size) {
  //fprintf(stderr, "[DEBUG] updateParam() name = '%s'   value = '%s' list_size = "PIOLONG_FMT"\n", name, *value, list_size);

  // Retrieve our inner param def
  paramDef *currentParamDef = getParamDef(name, __TAG__paramDef_list, __TAG__paramDef_list_size);
  if (currentParamDef == NULL) {
    //fprintf(stderr, "ERROR: \n", name);
    return 3;
  }
  // Prevent redefinition
  if (currentParamDef->found) {
    fprintf(stderr, "ERROR: param '%s' already defined!\n", name);
    return 4;
  }
  // Mark the param as found
  currentParamDef->found = true;


  // Auto gen by python script
  __AUTO_GEN_PARAM_AFFECTATION__


  return 0;
}


PyObject *__TAG__readParam(__TAG__parContent *param, char *filename) {
  // Parse the parameter file: read each line and update info in structure
  // if we encounter an error stop the process or print a warning depending of the severity.

  // check MPI rank
  char* pEnv;
  int mpi_rank;
  pEnv = getenv( "OMPI_COMM_WORLD_RANK"); // openmpi
  if (pEnv == NULL) {
    pEnv = getenv( "SLURM_PROCID"); // http://slurm.schedmd.com/sbatch.html
  }
  if (pEnv == NULL) {
    pEnv = getenv( "PMI_RANK"); // datarmor mpicc
  }
  if (pEnv == NULL) {
    mpi_rank = 0;
  } else {
    mpi_rank = atoi( pEnv);
  }

  if (mpi_rank == 0) {
    fprintf( stderr, "\n\n__TAG__readParam() from file \"%s\"\n",filename);
  }

  // Init the structure to ensure all flag are set to false by default
  memset(param, 0, sizeof(__TAG__parContent));

  // Open the param file
  PyObject * pyParams = load_PyParams(filename);
  if (pyParams == NULL) {
    fprintf(stderr, "ERROR while trying to open parameter file: '%s'\n", filename);
    PyErr_Print();
    perror("Error");
    exit(-1);
    return NULL;
  }

  // Init the internal structure allowing to know if a parameter has already appeared.
  for (int i=0; i < __TAG__paramDef_list_size; i++) {
    __TAG__paramDef_list[i].found = false;
  }

  // Init the list values
  PIOLONG currentListIndex = 0; // the index of next element to be read
  PIOSTRING *currentListValues = NULL; // The array of PIOSTRING to store all values of the list
  char value[MAX_LINE_LENGTH];

  for(int i =0;i<__TAG__paramDef_list_size;i++){
    int flag_parsing = 0; 
    currentListIndex = 0;

    int valid_param = testParam(pyParams,__TAG__paramDef_list[i].name);
    
    //if params is in pyParams
    if(valid_param == 0){     
      char * name = __TAG__paramDef_list[i].name;
      //If list of params
      
      if(__TAG__paramDef_list[i].isList){    
        int ListSize = getListSize(pyParams,name);
	      //If list not null
	      if(ListSize!=-1) {
	        //create list values params
          currentListValues = malloc(ListSize * sizeof(PIOSTRING));

	        while(currentListIndex!=ListSize && flag_parsing == 0){
              PyObject * pyValue =getItemParam(pyParams,__TAG__paramDef_list[i].name,currentListIndex);  
              if(pyValue != NULL){
                //PIOSTRING * value = PyUnicode_AsUTF8(PyObject_Str(pyValue));
		//strncpy(value,PyUnicode_AsUTF8(PyObject_Str(pyValue)),MAX_LINE_LENGTH);
       
                #if PY_MAJOR_VERSION >= 3
		strncpy(value,PyUnicode_AsUTF8(PyObject_Str(pyValue)),MAX_LINE_LENGTH-1);
		#else
		strncpy(value,PyString_AsString(PyObject_Str(pyValue)),MAX_LINE_LENGTH-1);
		#endif
		
		// Store the list value
                strcpy(currentListValues[currentListIndex], value); // -1 since array is 0 indexed!
                currentListIndex++;		            
              }else{
                flag_parsing =1;
              }
            }
	 
            // Save List parameter to param structure
            __TAG__updateParam(param,name,currentListValues,ListSize);
          }
      }else{
        // Save simple parameters to param structure
        PyObject * pyValue =getParam(pyParams,__TAG__paramDef_list[i].name);
        if(pyValue != NULL){
          PIOSTRING *value = (PIOSTRING *) PyUnicode_AsUTF8(PyObject_Str(pyValue));
          __TAG__updateParam(param,name,value,0);
        }
      }
    }
  }    
  return pyParams;
}



/*

int __TAG__readParam(__TAG__parContent *param, char *filename) {

  // Parse the parameter file: read each line and update info in structure
  // if we encounter an error stop the process or print a warning depending of the severity.

  // check MPI rank
  char* pEnv;
  int mpi_rank;
  pEnv = getenv( "OMPI_COMM_WORLD_RANK"); // openmpi
  if (pEnv == NULL) {
    pEnv = getenv( "SLURM_PROCID"); // http://slurm.schedmd.com/sbatch.html
  }
  if (pEnv == NULL) {
    pEnv = getenv( "PMI_RANK"); // datarmor mpicc
  }
  if (pEnv == NULL) {
    mpi_rank = 0;
  } else {
    mpi_rank = atoi( pEnv);
  }

  if (mpi_rank == 0) {
    fprintf( stderr, "\n\n__TAG__readParam() from file \"%s\"\n", filename);
  }

  // Init the structure to ensure all flag are set to false by default
  memset(param, 0, sizeof(__TAG__parContent));

  // Open the param file
  FILE *fp = fopen(filename, "r");
  if (fp == NULL) {
    fprintf(stderr, "ERROR while trying to open parameter file: '%s'\n", filename);
    perror("Error");
    return 1;
  }

  // Init the internal structure allowing to know if a parameter has already appeared.
  for (int i=0; i < __TAG__paramDef_list_size; i++) {
    __TAG__paramDef_list[i].found = false;
  }

  // Init the list values
  char *currentListName = NULL; // The list name (= the parameter name for the list)
  PIOLONG currentListTotalNumber = 0; // The total number of element in the list
  PIOLONG currentListIndex = 0; // the index of next element to be read
  PIOSTRING *currentListValues = NULL; // The array of PIOSTRING to store all values of the list

  // Init of parsing values
  char *s;
  char buff[MAX_LINE_LENGTH];
  int currentLine = 1;

  // Loop on each line of the parameter file
  while (fgets(buff, sizeof buff, fp) != NULL) {
    //fprintf(stderr, "[DEBUG] *** line #%d: '%s'\nstrlen(buff)= %zd\n", currentLine, buff, strlen(buff));

    // Check that line is not too long!
    if (strlen(buff) == (MAX_LINE_LENGTH-1)) { // -1 since we do not count the last char '\0'
      // In log we specify MAX_LINE_LENGTH-3 since we remove the new line char and the '\0' and take one more char to be sure we don't exceed.
      fprintf(stderr, "ERROR parameter file: '%s' has its line #%d too long! (max is %d chars)\n", filename, currentLine, MAX_LINE_LENGTH-3);
      return 1;
    }

    int firstChar = 0;
    while (isspace(buff[firstChar])) {
      firstChar++;
    }
    // Skip blank lines and comments
    if ((firstChar == strlen(buff)) || buff[firstChar] == '\n' || buff[firstChar] == '#') {
      //fprintf(stderr, "[DEBUG] line %d is empty or comment\n", currentLine);
      // Update line counter
      currentLine++;
      continue;
    }

    // Parse name/value pair from line
    char name[MAX_LINE_LENGTH], value[MAX_LINE_LENGTH];
    s = strtok(buff, "=");
    if (s==NULL) {
      fprintf(stderr, "ERROR: Missing param affectation symbol '=' at line %d\n", currentLine);
      //fprintf(stderr, "[DEBUG] line: %s\n", buff);
      return 1;
    }
    else {
      s = trim(s);
      strncpy(name, s, MAX_LINE_LENGTH);
    }
    s = strtok (NULL, "=");
    if (s==NULL || strlen(trim(s)) == 0) {
      fprintf(stderr, "ERROR: Missing param value at line %d\n", currentLine);
      //fprintf(stderr, "[DEBUG] line: %s\n", buff);
      return 1;
    }
    else {
      s = trim(s);
      strncpy(value, s, MAX_LINE_LENGTH);
    }

    if (mpi_rank == 0) {
      fprintf( stderr, "%s: reading %s = %s\n", __FILE__, name, value);
    }

    // Check if we are in a list reading phase
    if (currentListName != NULL) {
      char list_elt_to_be_read[MAX_LINE_LENGTH]; // Allow to store the name of the expected parameter (in case of list)
      sprintf(list_elt_to_be_read, "%s"PIOLONG_FMT"", currentListName, currentListIndex);
      if (strcmp(name, list_elt_to_be_read) != 0) {
        fprintf(stderr, "ERROR: We were expecting list param '%s' at line %d, but found '%s'\n",
            list_elt_to_be_read, currentLine, name);
        return 1;
      }

      // Store the list value
      strcpy(currentListValues[currentListIndex-1], value); // -1 since array is 0 indexed!

      // Handle end of list
      if (currentListIndex == currentListTotalNumber) {
        // Save List to param structure
        if (__TAG__updateParam(param, currentListName, currentListValues, currentListTotalNumber) != 0) {
          free(currentListName);
          return 1;
        }
        // Reset list name
        free(currentListName);
        currentListName = NULL;
      } else {
        currentListIndex++;
      }
      // Update line counter
      currentLine++;
      continue;
    }

    // Handle special param prefix: PARAM_PREFIX_LIST ("number_of_")
    if (startsWith(name, PARAM_PREFIX_LIST) == 0) {
      //fprintf(stderr, "[DEBUG] we detect a list number prefix at line: %d\n", currentLine);
      // Update info with number of element to be read...
      // - Save the current list param name
      currentListName = strdupnodmc(name+strlen(PARAM_PREFIX_LIST));
      if (currentListName == NULL) {
        perror("Error");
        return 1;
      }
      //fprintf(stderr, "[DEBUG] list param name: '%s'\n", currentListName);

      // Retrieve our inner param def
      paramDef *currentParamDef = getParamDef(currentListName, __TAG__paramDef_list, __TAG__paramDef_list_size);
      if (currentParamDef == NULL) {
        fprintf(stderr, "ERROR (line #%d): 'number_of' parameter refer to an invalid element '%s'\n", currentLine, currentListName);
        return 1;
      }

      // Check that the "number_of" refered to an existing element of type list
      if (!currentParamDef->isList) {
        fprintf(stderr, "ERROR (line #%d): 'number_of' parameter refer to a none list element '%s'\n", currentLine, currentListName);
        return 1;
      }
      
      // - Update info about list
      errno = 0;
      currentListTotalNumber = myRead_PIOLONG(value);
      if (errno != 0) {
        fprintf(stderr, "ERROR (line #%d): Unable to convert value '%s' to target type %s\n", currentLine, value, "PIOLONG");
        //perror("Error");
        return 1;
      }
      //fprintf(stderr, "[DEBUG] list param total number: "PIOLONG_FMT"\n", currentListTotalNumber);

      // Check that "number_of" can't be negative
      if (currentListTotalNumber < 0) {
        fprintf(stderr, "ERROR (line #%d): 'number_of' parameter can't be negative!\n", currentLine);
        return 1;
      }

      // Check that if param is required, the "number_of" can't be 0
      if (currentListTotalNumber == 0) {
        // Retrieve mandatory bool
        bool mandatory = currentParamDef->mandatory;

        if (mandatory) {
          fprintf(stderr, "ERROR (line %d): 'number_of' parameter can't be 0 for the mandatory element '%s'!\n", currentLine, currentListName);
          return 1;
        } else {
          // In this case we expect no other parameters of this name!
          // We just "ignore" the 'number_of' element...

          // Reset list name
          free(currentListName);
          currentListName = NULL;
        }
      } else {
        currentListIndex = 1; // the index to be read next!
        // Allocate memory for storing list values (values will be converted later)
        currentListValues = malloc(currentListTotalNumber * sizeof(PIOSTRING));
        if (currentListValues == NULL) {
          perror("Error");
          return 1;
        }
      }

      // Update line counter
      currentLine++;
      continue;
    }

    // In case of a simple parameter
    if (__TAG__updateParam(param, name, &value, 0) != 0) {
      return 1;
    }

    // Update line counter
    currentLine++;
  }
  
  //fprintf(stderr, "[DEBUG] End of parsing!\n");

  // Make some check

  // - Check that if we were reading list we read all elements otherwise print error msg.
  if (currentListName != NULL) {
    fprintf(stderr, "ERROR: missing some elements definition for parameter '%s'\n", currentListName);
    return 1;
  }

  // - All mandatory param must have been read! (see 'mandatory' and 'found')
  // Loop on all param def
  int i;
  for (i = 0; i < __TAG__paramDef_list_size; i++) {
    if (__TAG__paramDef_list[i].mandatory && (!__TAG__paramDef_list[i].found)) {
      fprintf(stderr, "ERROR: Missing mandatory parameter '%s'\n", __TAG__paramDef_list[i].name);
      return 1;
    }
  }

  //fprintf(stderr, "[DEBUG] Parameter file successfully parsed!\n");

  return 0;
}

*/
