/******************************************************************************
 * "sroll_parLoader.c"
 * 
 * This file has been generated by the ParLoader.
 *
 * This file is able to read a text parameter file (key=value) and load the
 * corresponding content to the specified structure.
 *
 * author:  Christan Madsen
 * date:    2015-04-03 (initial)
 * version: BETA
 *****************************************************************************/

#include <stdbool.h>
#include <stdlib.h>
#include <ctype.h>
#include <errno.h>
#include <string.h>
#include <Python.h>

#include "sroll_parLoader.h"
#include "no_dmc_util.h" // Make use of several utils from the NO_DMC_LIB
//#include "no_dmc_debug.h"


// *** START INCLUDE GUARD ****************************************************
// The following is common to all parLoader 'instance'.

#ifndef _PARLOADER_C_GUARD
#define _PARLOADER_C_GUARD


// TODO to see if need to be set as PIOSTRING MAX LENGTH...
#define MAX_LINE_LENGTH 256

// This is the prefix used in parameter file to indicate the list number element
#define PARAM_PREFIX_LIST "number_of_"


// This structure allow to store parameters information
typedef struct {
  char *name;     // name of the parameter
  bool isList;    // 'false' for standard and 'true' for list
  bool mandatory; // 'true' if param presence is mandatory, 'false' otherwise. Note that in case of 'false' we have to update the flag value.
  bool found;     // to remember if we found the param
//  char *type;     // data type of the parameter : will be used for convertion from string to value. Type can be any of those listed in no_dmc_piolib_type_def.h
} paramDef;


//plip
/* ---------------------------------------------------------------------------------*/
int getListSize_old(PyObject * params,char * name){
  /* Function that return the size of list via list name */
  //name = "number_of_"+name
  //name = strcat("number_of_",name);
  int sizeNewName = strlen(PARAM_PREFIX_LIST)+ strlen( name ) + 1;
  char * newName = (char *) malloc( sizeNewName );

  strcpy(newName,PARAM_PREFIX_LIST);
  strcat(newName,name);

  int tmp_value = (int) PyLong_AsLong(PyDict_GetItemString(params,newName));

  free(newName);

  return tmp_value;
}
/* ---------------------------------------------------------------------------------*/
int getListSize(PyObject * params,char * name){
  /* Function that return the size of list via list name */
  //name = "number_of_"+name
  //name = strcat("number_of_",name);

  int size;
  PyObject * tmp = PyDict_GetItemString(params,name);
  size=(int)PyList_Size(tmp);


  return size;
}

/* ---------------------------------------------------------------------------------*/
int testParam(PyObject * params,char * name){
 /* test if name is in parameters list with keywords form PyObject =>params
  Params needed :
    name = keyword
  */
  PyObject * tmp_value=PyDict_GetItemString(params,name);
  if(tmp_value == NULL) return 1;
  return 0;
}
/* ---------------------------------------------------------------------------------*/
void strip_ext(char *fname)
{
    char *end = fname + strlen(fname);

    while (end > fname && *end != '.') {
        --end;
    }

    if (end > fname) {
        *end = '\0';
    }
}
/* ---------------------------------------------------------------------------------*/
PyObject * load_PyParams(char* path){
    /* Load python parameters form file gived in parameters path */    

    // init variables
    PyObject *pName, *pModule, *pDict, *pFunc;
    PyObject * params;


    // Initialize the Python Interpreter
    Py_Initialize();

    strip_ext(path);
    
    //add current path to python
    PyRun_SimpleString("import sys");
    PyRun_SimpleString("import os");
    PyRun_SimpleString("sys.path.append(os.getcwd())");

    // Build the name object
    pName = PyUnicode_FromString(path);
    
    // Load the module object
    pModule = PyImport_Import(pName);

    if ((pModule = PyImport_Import(pName)) == NULL) {
      fprintf(stderr,"Error: PyImport_Import\n");
      exit(0);
    }
 
    // pDict is a borrowed reference 
    pDict = PyModule_GetDict(pModule);

    // pFunc is also a borrowed reference 
    pFunc = PyDict_GetItemString(pDict, "main");

    if (PyCallable_Check(pFunc)){
        params = PyObject_CallObject(pFunc, NULL);
        
    }else{
        PyErr_Print();
        exit(0);
    }

    
 return params;
  
}
/* ---------------------------------------------------------------------------------*/
PyObject * getParam(PyObject * params,char * pName){
  /* get parameters with keywords form PyObject =>params 
  Params needed : 
    pName = keyword
  */ 
  
  PyObject * tmp_value=PyDict_GetItemString(params,pName);
  
  return tmp_value;

}
/* ---------------------------------------------------------------------------------*/
PyObject * getItemParam(PyObject * params,char * pName,int index){
  /* get item from parameter with keywords and index form PyObject =>params 
  Params needed : 
    pName = keyword
    index = index of the return param
   */  

  PyObject * tmp_value=PyDict_GetItemString(params,pName);

  tmp_value =PyList_GetItem(tmp_value,index);
  return tmp_value;

}
/* ---------------------------------------------------------------------------------*/



/**
 * Extract PIODOUBLE from the specified string value.
 */
PIODOUBLE myRead_PIODOUBLE(PIOSTRING value) {
  char *endptr;
  PIODOUBLE tmpval;
  
  tmpval = strtod(value, &endptr);

  // Ensure that all chars are converted to value, otherwise act like if it was an error.
  if (*endptr != '\0') {
    errno = EILSEQ;
  }

  return tmpval;
}

/**
 * Extract PIOLONG from the specified string value.
 */
PIOLONG myRead_PIOLONG(PIOSTRING value) {
  char *endptr;
  PIOLONG tmpval;
  
  tmpval = strtol(value, &endptr, 10);

  // Ensure that all chars are converted to value, otherwise act like if it was an error.
  if (*endptr != '\0') {
    errno = EILSEQ;
  }

  return tmpval;
}

/**
 * Extract PIOFLOAT from the specified string value.
 */
PIOFLOAT myRead_PIOFLOAT(PIOSTRING value) {
  char *endptr;
  PIOFLOAT tmpval;

  tmpval = strtof(value, &endptr);

  // Ensure that all chars are converted to value, otherwise act like if it was an error.
  if (*endptr != '\0') {
    errno = EILSEQ;
  }

  return tmpval;
}

/**
 * Extract PIOINT from the specified string value.
 */
PIOINT myRead_PIOINT(PIOSTRING value) {
  char *endptr;
  PIOINT tmpval;

  tmpval = strtol(value, &endptr, 10);

  // Ensure that all chars are converted to value, otherwise act like if it was an error.
  if (*endptr != '\0') {
    errno = EILSEQ;
  }

  return tmpval;
}

// Not that there is no myRead_PIOSTRING() since the conversion is unecessary!

/**
 * Allow to retrieve the corresponding paramDef (if any) regarding the name pass in arg.
 */
paramDef *getParamDef(char *name, paramDef paramDef_list[], int paramDef_list_size) {

  int i;
  for (i = 0; i < paramDef_list_size; i++) {
    if (strcmp(name, paramDef_list[i].name) == 0) {
      return &paramDef_list[i];
    }
  }
  
  fprintf(stderr, "ERROR: Invalid parameter '%s': not defined in struct header file!\n", name);
  return NULL;
}

#endif
// *** END INCLUDE GUARD ******************************************************


// Auto generated by the python script
paramDef sroll_paramDef_list[] = {
  {"BeginRing", false, true, false},
  {"EndRing", false, true, false},
  {"CrossPol", true, true, false},
  {"Calibration", true, true, false},
  {"seuilcond", false, true, false},
  {"NEP", true, true, false},
  {"Monop", true, true, false},
  {"bolomask", true, true, false},
  {"SEED", true, true, false},
  {"FITANGLE", false, true, false},
  {"FITPOLEFF", false, true, false},
  {"OUT_NOPOL", true, true, false},
  {"FSLCOEF", true, true, false},
  {"D_NOPOL", false, true, false},
  {"SAVEINTMAP", false, true, false},
  {"CALCODUST", false, true, false},
  {"DOMAXVRAIE", false, true, false},
  {"DOGAINDIP", false, true, false},
  {"CUTRG", false, true, false},
  {"AVGR0", false, false, false},
  {"DODIPCAL", false, true, false},
  {"TESTPOL", false, true, false},
  {"RSTEP", false, true, false},
  {"GAINSTEP", false, true, false},
  {"Nside", false, true, false},
  {"XI2STOP", false, true, false},
  {"AVGCO", false, true, false},
  {"AVGDUST", false, true, false},
  {"NITT", false, true, false},
  {"NADU", false, true, false},
  {"NADUSTEP", false, true, false},
  {"REMDIP", false, true, false},
  {"in_template_map_I", false, true, false},
  {"in_template_map_Q", false, true, false},
  {"in_template_map_U", false, true, false},
  {"REFMAPI", false, false, false},
  {"REFMAPQ", false, false, false},
  {"REFMAPU", false, false, false},
  {"REMHDIP", false, false, false},
  {"TEMPLATEMAP", false, false, false},
  {"Signal_noPS", true, false, false},
  {"invgi", true, false, false},
  {"fsl", true, false, false},
  {"Theo_noPS", true, false, false},
  {"ADU", true, false, false},
  {"Theo_CO", false, false, false},
  {"Theo_13CO", false, false, false},
  {"in_polar_fit_Q", false, false, false},
  {"in_polar_fit_U", false, false, false},
  {"Theo_FREEFREE", false, false, false},
  {"Theo_Dust_I", false, false, false},
  {"Theo_Dust_Q", false, false, false},
  {"Theo_Dust_U", false, false, false},
  {"Sim_Dust_Q", false, false, false},
  {"Sim_Dust_U", false, false, false},
  {"Ptg_noPS", true, false, false},
  {"Hit_noPS", true, false, false},
  {"ALMMAP", true, false, false},
  {"DipOrb_noPS", true, false, false},
  {"Badring", true, false, false},
  {"VarGain", true, false, false},
  {"Mask", false, false, false},
  {"MAP", true, false, false},
  {"Out_Offset", true, false, false},
  {"Out_Offset_corr", true, false, false},
  {"Out_xi2", true, false, false},
  {"Out_xi2_corr", true, false, false},
  {"verbose", false, false, false},
  {"dmc_output_path", false, false, false},
  {"dmc_error_path", false, false, false},
  {"stim_paramfiles", true, false, false},
  {"MAPRINGS", true, false, false},
  {"ADDDIP", false, false, false},
  {"KCMBIN", false, false, false},
  {"addHPR_name", true, false, false},
  {"addHPR_factor", true, false, false},
  {"addHPR_watts", true, false, false},
  {"AVGCO143", false, false, false},
  {"AVGDUST100", false, false, false},
  {"saveCOV", false, false, false},
  {"delta_psi", false, false, false},
};
int sroll_paramDef_list_size = 81;



/**
 * Allow to update (ie. store) the parameter value(s) in the structure.
 *
 * @param list_size the size of the list (if any) otherwise the value is ignored.
 */
int sroll_updateParam(sroll_parContent *param, char *name, PIOSTRING *value, PIOLONG list_size) {
  //fprintf(stderr, "[DEBUG] updateParam() name = '%s'   value = '%s' list_size = "PIOLONG_FMT"\n", name, *value, list_size);

  // Retrieve our inner param def
  paramDef *currentParamDef = getParamDef(name, sroll_paramDef_list, sroll_paramDef_list_size);
  if (currentParamDef == NULL) {
    //fprintf(stderr, "ERROR: \n", name);
    return 3;
  }
  // Prevent redefinition
  if (currentParamDef->found) {
    fprintf(stderr, "ERROR: param '%s' already defined!\n", name);
    return 4;
  }
  // Mark the param as found
  currentParamDef->found = true;


  // Auto gen by python script
  // Copy into correct entry in parameters struct
  if (strcmp(name, "BeginRing") == 0) {
    errno = 0;
    param->BeginRing = myRead_PIOLONG(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'BeginRing': Unable to convert value '%s' to target type %s\n", *value, "PIOLONG");
      return 1;
    }
  }
  else if (strcmp(name, "EndRing") == 0) {
    errno = 0;
    param->EndRing = myRead_PIOLONG(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'EndRing': Unable to convert value '%s' to target type %s\n", *value, "PIOLONG");
      return 1;
    }
  }
  else if (strcmp(name, "CrossPol") == 0) {
    param->n_CrossPol = list_size;
    param->CrossPol = malloc(list_size * sizeof(PIODOUBLE));
    if (param->CrossPol == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->CrossPol[i] = myRead_PIODOUBLE(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'CrossPol': Unable to convert value '%s' to target type %s\n", value[i], "PIODOUBLE");
        return 1;
      }
    }
  }
  else if (strcmp(name, "Calibration") == 0) {
    param->n_Calibration = list_size;
    param->Calibration = malloc(list_size * sizeof(PIODOUBLE));
    if (param->Calibration == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->Calibration[i] = myRead_PIODOUBLE(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'Calibration': Unable to convert value '%s' to target type %s\n", value[i], "PIODOUBLE");
        return 1;
      }
    }
  }
  else if (strcmp(name, "seuilcond") == 0) {
    errno = 0;
    param->seuilcond = myRead_PIODOUBLE(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'seuilcond': Unable to convert value '%s' to target type %s\n", *value, "PIODOUBLE");
      return 1;
    }
  }
  else if (strcmp(name, "NEP") == 0) {
    param->n_NEP = list_size;
    param->NEP = malloc(list_size * sizeof(PIODOUBLE));
    if (param->NEP == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->NEP[i] = myRead_PIODOUBLE(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'NEP': Unable to convert value '%s' to target type %s\n", value[i], "PIODOUBLE");
        return 1;
      }
    }
  }
  else if (strcmp(name, "Monop") == 0) {
    param->n_Monop = list_size;
    param->Monop = malloc(list_size * sizeof(PIODOUBLE));
    if (param->Monop == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->Monop[i] = myRead_PIODOUBLE(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'Monop': Unable to convert value '%s' to target type %s\n", value[i], "PIODOUBLE");
        return 1;
      }
    }
  }
  else if (strcmp(name, "bolomask") == 0) {
    param->n_bolomask = list_size;
    param->bolomask = malloc(list_size * sizeof(PIOINT));
    if (param->bolomask == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->bolomask[i] = myRead_PIOINT(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'bolomask': Unable to convert value '%s' to target type %s\n", value[i], "PIOINT");
        return 1;
      }
    }
  }
  else if (strcmp(name, "SEED") == 0) {
    param->n_SEED = list_size;
    param->SEED = malloc(list_size * sizeof(PIOINT));
    if (param->SEED == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->SEED[i] = myRead_PIOINT(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'SEED': Unable to convert value '%s' to target type %s\n", value[i], "PIOINT");
        return 1;
      }
    }
  }
  else if (strcmp(name, "FITANGLE") == 0) {
    errno = 0;
    param->FITANGLE = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'FITANGLE': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "FITPOLEFF") == 0) {
    errno = 0;
    param->FITPOLEFF = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'FITPOLEFF': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "OUT_NOPOL") == 0) {
    param->n_OUT_NOPOL = list_size;
    param->OUT_NOPOL = malloc(list_size * sizeof(PIOINT));
    if (param->OUT_NOPOL == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->OUT_NOPOL[i] = myRead_PIOINT(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'OUT_NOPOL': Unable to convert value '%s' to target type %s\n", value[i], "PIOINT");
        return 1;
      }
    }
  }
  else if (strcmp(name, "FSLCOEF") == 0) {
    param->n_FSLCOEF = list_size;
    param->FSLCOEF = malloc(list_size * sizeof(PIOFLOAT));
    if (param->FSLCOEF == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->FSLCOEF[i] = myRead_PIOFLOAT(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'FSLCOEF': Unable to convert value '%s' to target type %s\n", value[i], "PIOFLOAT");
        return 1;
      }
    }
  }
  else if (strcmp(name, "D_NOPOL") == 0) {
    errno = 0;
    param->D_NOPOL = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'D_NOPOL': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "SAVEINTMAP") == 0) {
    errno = 0;
    param->SAVEINTMAP = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'SAVEINTMAP': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "CALCODUST") == 0) {
    errno = 0;
    param->CALCODUST = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'CALCODUST': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "DOMAXVRAIE") == 0) {
    errno = 0;
    param->DOMAXVRAIE = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'DOMAXVRAIE': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "DOGAINDIP") == 0) {
    errno = 0;
    param->DOGAINDIP = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'DOGAINDIP': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "CUTRG") == 0) {
    errno = 0;
    param->CUTRG = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'CUTRG': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "AVGR0") == 0) {
    param->flag_AVGR0 = _PAR_TRUE;
    errno = 0;
    param->AVGR0 = myRead_PIODOUBLE(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'AVGR0': Unable to convert value '%s' to target type %s\n", *value, "PIODOUBLE");
      return 1;
    }
  }
  else if (strcmp(name, "DODIPCAL") == 0) {
    errno = 0;
    param->DODIPCAL = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'DODIPCAL': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "TESTPOL") == 0) {
    errno = 0;
    param->TESTPOL = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'TESTPOL': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "RSTEP") == 0) {
    errno = 0;
    param->RSTEP = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'RSTEP': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "GAINSTEP") == 0) {
    errno = 0;
    param->GAINSTEP = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'GAINSTEP': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "Nside") == 0) {
    errno = 0;
    param->Nside = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'Nside': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "XI2STOP") == 0) {
    errno = 0;
    param->XI2STOP = myRead_PIODOUBLE(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'XI2STOP': Unable to convert value '%s' to target type %s\n", *value, "PIODOUBLE");
      return 1;
    }
  }
  else if (strcmp(name, "AVGCO") == 0) {
    errno = 0;
    param->AVGCO = myRead_PIODOUBLE(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'AVGCO': Unable to convert value '%s' to target type %s\n", *value, "PIODOUBLE");
      return 1;
    }
  }
  else if (strcmp(name, "AVGDUST") == 0) {
    errno = 0;
    param->AVGDUST = myRead_PIODOUBLE(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'AVGDUST': Unable to convert value '%s' to target type %s\n", *value, "PIODOUBLE");
      return 1;
    }
  }
  else if (strcmp(name, "NITT") == 0) {
    errno = 0;
    param->NITT = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'NITT': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "NADU") == 0) {
    errno = 0;
    param->NADU = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'NADU': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "NADUSTEP") == 0) {
    errno = 0;
    param->NADUSTEP = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'NADUSTEP': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "REMDIP") == 0) {
    errno = 0;
    param->REMDIP = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'REMDIP': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "in_template_map_I") == 0) {
    strcpy(param->in_template_map_I, *value);
  }
  else if (strcmp(name, "in_template_map_Q") == 0) {
    strcpy(param->in_template_map_Q, *value);
  }
  else if (strcmp(name, "in_template_map_U") == 0) {
    strcpy(param->in_template_map_U, *value);
  }
  else if (strcmp(name, "REFMAPI") == 0) {
    param->flag_REFMAPI = _PAR_TRUE;
    strcpy(param->REFMAPI, *value);
  }
  else if (strcmp(name, "REFMAPQ") == 0) {
    param->flag_REFMAPQ = _PAR_TRUE;
    strcpy(param->REFMAPQ, *value);
  }
  else if (strcmp(name, "REFMAPU") == 0) {
    param->flag_REFMAPU = _PAR_TRUE;
    strcpy(param->REFMAPU, *value);
  }
  else if (strcmp(name, "REMHDIP") == 0) {
    param->flag_REMHDIP = _PAR_TRUE;
    errno = 0;
    param->REMHDIP = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'REMHDIP': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "TEMPLATEMAP") == 0) {
    param->flag_TEMPLATEMAP = _PAR_TRUE;
    strcpy(param->TEMPLATEMAP, *value);
  }
  else if (strcmp(name, "Signal_noPS") == 0) {
    param->flag_Signal_noPS = _PAR_TRUE;
    param->n_Signal_noPS = list_size;
    param->Signal_noPS = malloc(list_size * sizeof(PIOSTRING));
    if (param->Signal_noPS == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->Signal_noPS[i], value[i]);
    }
  }
  else if (strcmp(name, "invgi") == 0) {
    param->flag_invgi = _PAR_TRUE;
    param->n_invgi = list_size;
    param->invgi = malloc(list_size * sizeof(PIOSTRING));
    if (param->invgi == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->invgi[i], value[i]);
    }
  }
  else if (strcmp(name, "fsl") == 0) {
    param->flag_fsl = _PAR_TRUE;
    param->n_fsl = list_size;
    param->fsl = malloc(list_size * sizeof(PIOSTRING));
    if (param->fsl == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->fsl[i], value[i]);
    }
  }
  else if (strcmp(name, "Theo_noPS") == 0) {
    param->flag_Theo_noPS = _PAR_TRUE;
    param->n_Theo_noPS = list_size;
    param->Theo_noPS = malloc(list_size * sizeof(PIOSTRING));
    if (param->Theo_noPS == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->Theo_noPS[i], value[i]);
    }
  }
  else if (strcmp(name, "ADU") == 0) {
    param->flag_ADU = _PAR_TRUE;
    param->n_ADU = list_size;
    param->ADU = malloc(list_size * sizeof(PIOSTRING));
    if (param->ADU == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->ADU[i], value[i]);
    }
  }
  else if (strcmp(name, "Theo_CO") == 0) {
    param->flag_Theo_CO = _PAR_TRUE;
    strcpy(param->Theo_CO, *value);
  }
  else if (strcmp(name, "Theo_13CO") == 0) {
    param->flag_Theo_13CO = _PAR_TRUE;
    strcpy(param->Theo_13CO, *value);
  }
  else if (strcmp(name, "in_polar_fit_Q") == 0) {
    param->flag_in_polar_fit_Q = _PAR_TRUE;
    strcpy(param->in_polar_fit_Q, *value);
  }
  else if (strcmp(name, "in_polar_fit_U") == 0) {
    param->flag_in_polar_fit_U = _PAR_TRUE;
    strcpy(param->in_polar_fit_U, *value);
  }
  else if (strcmp(name, "Theo_FREEFREE") == 0) {
    param->flag_Theo_FREEFREE = _PAR_TRUE;
    strcpy(param->Theo_FREEFREE, *value);
  }
  else if (strcmp(name, "Theo_Dust_I") == 0) {
    param->flag_Theo_Dust_I = _PAR_TRUE;
    strcpy(param->Theo_Dust_I, *value);
  }
  else if (strcmp(name, "Theo_Dust_Q") == 0) {
    param->flag_Theo_Dust_Q = _PAR_TRUE;
    strcpy(param->Theo_Dust_Q, *value);
  }
  else if (strcmp(name, "Theo_Dust_U") == 0) {
    param->flag_Theo_Dust_U = _PAR_TRUE;
    strcpy(param->Theo_Dust_U, *value);
  }
  else if (strcmp(name, "Sim_Dust_Q") == 0) {
    param->flag_Sim_Dust_Q = _PAR_TRUE;
    strcpy(param->Sim_Dust_Q, *value);
  }
  else if (strcmp(name, "Sim_Dust_U") == 0) {
    param->flag_Sim_Dust_U = _PAR_TRUE;
    strcpy(param->Sim_Dust_U, *value);
  }
  else if (strcmp(name, "Ptg_noPS") == 0) {
    param->flag_Ptg_noPS = _PAR_TRUE;
    param->n_Ptg_noPS = list_size;
    param->Ptg_noPS = malloc(list_size * sizeof(PIOSTRING));
    if (param->Ptg_noPS == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->Ptg_noPS[i], value[i]);
    }
  }
  else if (strcmp(name, "Hit_noPS") == 0) {
    param->flag_Hit_noPS = _PAR_TRUE;
    param->n_Hit_noPS = list_size;
    param->Hit_noPS = malloc(list_size * sizeof(PIOSTRING));
    if (param->Hit_noPS == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->Hit_noPS[i], value[i]);
    }
  }
  else if (strcmp(name, "ALMMAP") == 0) {
    param->flag_ALMMAP = _PAR_TRUE;
    param->n_ALMMAP = list_size;
    param->ALMMAP = malloc(list_size * sizeof(PIOSTRING));
    if (param->ALMMAP == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->ALMMAP[i], value[i]);
    }
  }
  else if (strcmp(name, "DipOrb_noPS") == 0) {
    param->flag_DipOrb_noPS = _PAR_TRUE;
    param->n_DipOrb_noPS = list_size;
    param->DipOrb_noPS = malloc(list_size * sizeof(PIOSTRING));
    if (param->DipOrb_noPS == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->DipOrb_noPS[i], value[i]);
    }
  }
  else if (strcmp(name, "Badring") == 0) {
    param->flag_Badring = _PAR_TRUE;
    param->n_Badring = list_size;
    param->Badring = malloc(list_size * sizeof(PIOSTRING));
    if (param->Badring == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->Badring[i], value[i]);
    }
  }
  else if (strcmp(name, "VarGain") == 0) {
    param->flag_VarGain = _PAR_TRUE;
    param->n_VarGain = list_size;
    param->VarGain = malloc(list_size * sizeof(PIOSTRING));
    if (param->VarGain == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->VarGain[i], value[i]);
    }
  }
  else if (strcmp(name, "Mask") == 0) {
    param->flag_Mask = _PAR_TRUE;
    strcpy(param->Mask, *value);
  }
  else if (strcmp(name, "MAP") == 0) {
    param->flag_MAP = _PAR_TRUE;
    param->n_MAP = list_size;
    param->MAP = malloc(list_size * sizeof(PIOSTRING));
    if (param->MAP == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->MAP[i], value[i]);
    }
  }
  else if (strcmp(name, "Out_Offset") == 0) {
    param->flag_Out_Offset = _PAR_TRUE;
    param->n_Out_Offset = list_size;
    param->Out_Offset = malloc(list_size * sizeof(PIOSTRING));
    if (param->Out_Offset == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->Out_Offset[i], value[i]);
    }
  }
  else if (strcmp(name, "Out_Offset_corr") == 0) {
    param->flag_Out_Offset_corr = _PAR_TRUE;
    param->n_Out_Offset_corr = list_size;
    param->Out_Offset_corr = malloc(list_size * sizeof(PIOSTRING));
    if (param->Out_Offset_corr == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->Out_Offset_corr[i], value[i]);
    }
  }
  else if (strcmp(name, "Out_xi2") == 0) {
    param->flag_Out_xi2 = _PAR_TRUE;
    param->n_Out_xi2 = list_size;
    param->Out_xi2 = malloc(list_size * sizeof(PIOSTRING));
    if (param->Out_xi2 == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->Out_xi2[i], value[i]);
    }
  }
  else if (strcmp(name, "Out_xi2_corr") == 0) {
    param->flag_Out_xi2_corr = _PAR_TRUE;
    param->n_Out_xi2_corr = list_size;
    param->Out_xi2_corr = malloc(list_size * sizeof(PIOSTRING));
    if (param->Out_xi2_corr == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->Out_xi2_corr[i], value[i]);
    }
  }
  else if (strcmp(name, "verbose") == 0) {
    param->flag_verbose = _PAR_TRUE;
    errno = 0;
    param->verbose = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'verbose': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "dmc_output_path") == 0) {
    param->flag_dmc_output_path = _PAR_TRUE;
    strcpy(param->dmc_output_path, *value);
  }
  else if (strcmp(name, "dmc_error_path") == 0) {
    param->flag_dmc_error_path = _PAR_TRUE;
    strcpy(param->dmc_error_path, *value);
  }
  else if (strcmp(name, "stim_paramfiles") == 0) {
    param->flag_stim_paramfiles = _PAR_TRUE;
    param->n_stim_paramfiles = list_size;
    param->stim_paramfiles = malloc(list_size * sizeof(PIOSTRING));
    if (param->stim_paramfiles == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->stim_paramfiles[i], value[i]);
    }
  }
  else if (strcmp(name, "MAPRINGS") == 0) {
    param->flag_MAPRINGS = _PAR_TRUE;
    param->n_MAPRINGS = list_size;
    param->MAPRINGS = malloc(list_size * sizeof(PIOINT));
    if (param->MAPRINGS == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->MAPRINGS[i] = myRead_PIOINT(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'MAPRINGS': Unable to convert value '%s' to target type %s\n", value[i], "PIOINT");
        return 1;
      }
    }
  }
  else if (strcmp(name, "ADDDIP") == 0) {
    param->flag_ADDDIP = _PAR_TRUE;
    errno = 0;
    param->ADDDIP = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'ADDDIP': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "KCMBIN") == 0) {
    param->flag_KCMBIN = _PAR_TRUE;
    errno = 0;
    param->KCMBIN = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'KCMBIN': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "addHPR_name") == 0) {
    param->flag_addHPR_name = _PAR_TRUE;
    param->n_addHPR_name = list_size;
    param->addHPR_name = malloc(list_size * sizeof(PIOSTRING));
    if (param->addHPR_name == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->addHPR_name[i], value[i]);
    }
  }
  else if (strcmp(name, "addHPR_factor") == 0) {
    param->flag_addHPR_factor = _PAR_TRUE;
    param->n_addHPR_factor = list_size;
    param->addHPR_factor = malloc(list_size * sizeof(PIOFLOAT));
    if (param->addHPR_factor == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->addHPR_factor[i] = myRead_PIOFLOAT(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'addHPR_factor': Unable to convert value '%s' to target type %s\n", value[i], "PIOFLOAT");
        return 1;
      }
    }
  }
  else if (strcmp(name, "addHPR_watts") == 0) {
    param->flag_addHPR_watts = _PAR_TRUE;
    param->n_addHPR_watts = list_size;
    param->addHPR_watts = malloc(list_size * sizeof(PIOINT));
    if (param->addHPR_watts == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->addHPR_watts[i] = myRead_PIOINT(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'addHPR_watts': Unable to convert value '%s' to target type %s\n", value[i], "PIOINT");
        return 1;
      }
    }
  }
  else if (strcmp(name, "AVGCO143") == 0) {
    param->flag_AVGCO143 = _PAR_TRUE;
    errno = 0;
    param->AVGCO143 = myRead_PIODOUBLE(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'AVGCO143': Unable to convert value '%s' to target type %s\n", *value, "PIODOUBLE");
      return 1;
    }
  }
  else if (strcmp(name, "AVGDUST100") == 0) {
    param->flag_AVGDUST100 = _PAR_TRUE;
    errno = 0;
    param->AVGDUST100 = myRead_PIODOUBLE(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'AVGDUST100': Unable to convert value '%s' to target type %s\n", *value, "PIODOUBLE");
      return 1;
    }
  }
  else if (strcmp(name, "saveCOV") == 0) {
    param->flag_saveCOV = _PAR_TRUE;
    errno = 0;
    param->saveCOV = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'saveCOV': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "delta_psi") == 0) {
    param->flag_delta_psi = _PAR_TRUE;
    errno = 0;
    param->delta_psi = myRead_PIOFLOAT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'delta_psi': Unable to convert value '%s' to target type %s\n", *value, "PIOFLOAT");
      return 1;
    }
  }
  else {
    fprintf(stderr, "ERROR: %s: Unknown param name!\n", name);
    return 1;
  }



  return 0;
}


PyObject *sroll_readParam(sroll_parContent *param, char *filename) {
  // Parse the parameter file: read each line and update info in structure
  // if we encounter an error stop the process or print a warning depending of the severity.

  // check MPI rank
  char* pEnv;
  int mpi_rank;
  pEnv = getenv( "OMPI_COMM_WORLD_RANK"); // openmpi
  if (pEnv == NULL) {
    pEnv = getenv( "SLURM_PROCID"); // http://slurm.schedmd.com/sbatch.html
  }
  if (pEnv == NULL) {
    pEnv = getenv( "PMI_RANK"); // datarmor mpicc
  }
  if (pEnv == NULL) {
    mpi_rank = 0;
  } else {
    mpi_rank = atoi( pEnv);
  }

  if (mpi_rank == 0) {
    fprintf( stderr, "\n\nsroll_readParam() from file \"%s\"\n",filename);
  }

  // Init the structure to ensure all flag are set to false by default
  memset(param, 0, sizeof(sroll_parContent));

  // Open the param file
  PyObject * pyParams = load_PyParams(filename);
  if (pyParams == NULL) {
    fprintf(stderr, "ERROR while trying to open parameter file: '%s'\n", filename);
    PyErr_Print();
    perror("Error");
    exit(-1);
    return NULL;
  }

  // Init the internal structure allowing to know if a parameter has already appeared.
  for (int i=0; i < sroll_paramDef_list_size; i++) {
    sroll_paramDef_list[i].found = false;
  }

  // Init the list values
  PIOLONG currentListIndex = 0; // the index of next element to be read
  PIOSTRING *currentListValues = NULL; // The array of PIOSTRING to store all values of the list
  char value[MAX_LINE_LENGTH];

  for(int i =0;i<sroll_paramDef_list_size;i++){
    int flag_parsing = 0; 
    currentListIndex = 0;

    int valid_param = testParam(pyParams,sroll_paramDef_list[i].name);
    
    //if params is in pyParams
    if(valid_param == 0){     
      char * name = sroll_paramDef_list[i].name;
      //If list of params
      
      if(sroll_paramDef_list[i].isList){    
        int ListSize = getListSize(pyParams,name);
	      //If list not null
	      if(ListSize!=-1) {
	        //create list values params
          currentListValues = malloc(ListSize * sizeof(PIOSTRING));

	        while(currentListIndex!=ListSize && flag_parsing == 0){
              PyObject * pyValue =getItemParam(pyParams,sroll_paramDef_list[i].name,currentListIndex);  
              if(pyValue != NULL){
                //PIOSTRING * value = PyUnicode_AsUTF8(PyObject_Str(pyValue));
		//strncpy(value,PyUnicode_AsUTF8(PyObject_Str(pyValue)),MAX_LINE_LENGTH);
       
                #if PY_MAJOR_VERSION >= 3
		strncpy(value,PyUnicode_AsUTF8(PyObject_Str(pyValue)),MAX_LINE_LENGTH-1);
		#else
		strncpy(value,PyString_AsString(PyObject_Str(pyValue)),MAX_LINE_LENGTH-1);
		#endif
		
		// Store the list value
                strcpy(currentListValues[currentListIndex], value); // -1 since array is 0 indexed!
                currentListIndex++;		            
              }else{
                flag_parsing =1;
              }
            }
	 
            // Save List parameter to param structure
            sroll_updateParam(param,name,currentListValues,ListSize);
          }
      }else{
        // Save simple parameters to param structure
        PyObject * pyValue =getParam(pyParams,sroll_paramDef_list[i].name);
        if(pyValue != NULL){
          PIOSTRING *value = (PIOSTRING *) PyUnicode_AsUTF8(PyObject_Str(pyValue));
          sroll_updateParam(param,name,value,0);
        }
      }
    }
  }    
  return pyParams;
}



/*

int sroll_readParam(sroll_parContent *param, char *filename) {

  // Parse the parameter file: read each line and update info in structure
  // if we encounter an error stop the process or print a warning depending of the severity.

  // check MPI rank
  char* pEnv;
  int mpi_rank;
  pEnv = getenv( "OMPI_COMM_WORLD_RANK"); // openmpi
  if (pEnv == NULL) {
    pEnv = getenv( "SLURM_PROCID"); // http://slurm.schedmd.com/sbatch.html
  }
  if (pEnv == NULL) {
    pEnv = getenv( "PMI_RANK"); // datarmor mpicc
  }
  if (pEnv == NULL) {
    mpi_rank = 0;
  } else {
    mpi_rank = atoi( pEnv);
  }

  if (mpi_rank == 0) {
    fprintf( stderr, "\n\nsroll_readParam() from file \"%s\"\n", filename);
  }

  // Init the structure to ensure all flag are set to false by default
  memset(param, 0, sizeof(sroll_parContent));

  // Open the param file
  FILE *fp = fopen(filename, "r");
  if (fp == NULL) {
    fprintf(stderr, "ERROR while trying to open parameter file: '%s'\n", filename);
    perror("Error");
    return 1;
  }

  // Init the internal structure allowing to know if a parameter has already appeared.
  for (int i=0; i < sroll_paramDef_list_size; i++) {
    sroll_paramDef_list[i].found = false;
  }

  // Init the list values
  char *currentListName = NULL; // The list name (= the parameter name for the list)
  PIOLONG currentListTotalNumber = 0; // The total number of element in the list
  PIOLONG currentListIndex = 0; // the index of next element to be read
  PIOSTRING *currentListValues = NULL; // The array of PIOSTRING to store all values of the list

  // Init of parsing values
  char *s;
  char buff[MAX_LINE_LENGTH];
  int currentLine = 1;

  // Loop on each line of the parameter file
  while (fgets(buff, sizeof buff, fp) != NULL) {
    //fprintf(stderr, "[DEBUG] *** line #%d: '%s'\nstrlen(buff)= %zd\n", currentLine, buff, strlen(buff));

    // Check that line is not too long!
    if (strlen(buff) == (MAX_LINE_LENGTH-1)) { // -1 since we do not count the last char '\0'
      // In log we specify MAX_LINE_LENGTH-3 since we remove the new line char and the '\0' and take one more char to be sure we don't exceed.
      fprintf(stderr, "ERROR parameter file: '%s' has its line #%d too long! (max is %d chars)\n", filename, currentLine, MAX_LINE_LENGTH-3);
      return 1;
    }

    int firstChar = 0;
    while (isspace(buff[firstChar])) {
      firstChar++;
    }
    // Skip blank lines and comments
    if ((firstChar == strlen(buff)) || buff[firstChar] == '\n' || buff[firstChar] == '#') {
      //fprintf(stderr, "[DEBUG] line %d is empty or comment\n", currentLine);
      // Update line counter
      currentLine++;
      continue;
    }

    // Parse name/value pair from line
    char name[MAX_LINE_LENGTH], value[MAX_LINE_LENGTH];
    s = strtok(buff, "=");
    if (s==NULL) {
      fprintf(stderr, "ERROR: Missing param affectation symbol '=' at line %d\n", currentLine);
      //fprintf(stderr, "[DEBUG] line: %s\n", buff);
      return 1;
    }
    else {
      s = trim(s);
      strncpy(name, s, MAX_LINE_LENGTH);
    }
    s = strtok (NULL, "=");
    if (s==NULL || strlen(trim(s)) == 0) {
      fprintf(stderr, "ERROR: Missing param value at line %d\n", currentLine);
      //fprintf(stderr, "[DEBUG] line: %s\n", buff);
      return 1;
    }
    else {
      s = trim(s);
      strncpy(value, s, MAX_LINE_LENGTH);
    }

    if (mpi_rank == 0) {
      fprintf( stderr, "%s: reading %s = %s\n", __FILE__, name, value);
    }

    // Check if we are in a list reading phase
    if (currentListName != NULL) {
      char list_elt_to_be_read[MAX_LINE_LENGTH]; // Allow to store the name of the expected parameter (in case of list)
      sprintf(list_elt_to_be_read, "%s"PIOLONG_FMT"", currentListName, currentListIndex);
      if (strcmp(name, list_elt_to_be_read) != 0) {
        fprintf(stderr, "ERROR: We were expecting list param '%s' at line %d, but found '%s'\n",
            list_elt_to_be_read, currentLine, name);
        return 1;
      }

      // Store the list value
      strcpy(currentListValues[currentListIndex-1], value); // -1 since array is 0 indexed!

      // Handle end of list
      if (currentListIndex == currentListTotalNumber) {
        // Save List to param structure
        if (sroll_updateParam(param, currentListName, currentListValues, currentListTotalNumber) != 0) {
          free(currentListName);
          return 1;
        }
        // Reset list name
        free(currentListName);
        currentListName = NULL;
      } else {
        currentListIndex++;
      }
      // Update line counter
      currentLine++;
      continue;
    }

    // Handle special param prefix: PARAM_PREFIX_LIST ("number_of_")
    if (startsWith(name, PARAM_PREFIX_LIST) == 0) {
      //fprintf(stderr, "[DEBUG] we detect a list number prefix at line: %d\n", currentLine);
      // Update info with number of element to be read...
      // - Save the current list param name
      currentListName = strdupnodmc(name+strlen(PARAM_PREFIX_LIST));
      if (currentListName == NULL) {
        perror("Error");
        return 1;
      }
      //fprintf(stderr, "[DEBUG] list param name: '%s'\n", currentListName);

      // Retrieve our inner param def
      paramDef *currentParamDef = getParamDef(currentListName, sroll_paramDef_list, sroll_paramDef_list_size);
      if (currentParamDef == NULL) {
        fprintf(stderr, "ERROR (line #%d): 'number_of' parameter refer to an invalid element '%s'\n", currentLine, currentListName);
        return 1;
      }

      // Check that the "number_of" refered to an existing element of type list
      if (!currentParamDef->isList) {
        fprintf(stderr, "ERROR (line #%d): 'number_of' parameter refer to a none list element '%s'\n", currentLine, currentListName);
        return 1;
      }
      
      // - Update info about list
      errno = 0;
      currentListTotalNumber = myRead_PIOLONG(value);
      if (errno != 0) {
        fprintf(stderr, "ERROR (line #%d): Unable to convert value '%s' to target type %s\n", currentLine, value, "PIOLONG");
        //perror("Error");
        return 1;
      }
      //fprintf(stderr, "[DEBUG] list param total number: "PIOLONG_FMT"\n", currentListTotalNumber);

      // Check that "number_of" can't be negative
      if (currentListTotalNumber < 0) {
        fprintf(stderr, "ERROR (line #%d): 'number_of' parameter can't be negative!\n", currentLine);
        return 1;
      }

      // Check that if param is required, the "number_of" can't be 0
      if (currentListTotalNumber == 0) {
        // Retrieve mandatory bool
        bool mandatory = currentParamDef->mandatory;

        if (mandatory) {
          fprintf(stderr, "ERROR (line %d): 'number_of' parameter can't be 0 for the mandatory element '%s'!\n", currentLine, currentListName);
          return 1;
        } else {
          // In this case we expect no other parameters of this name!
          // We just "ignore" the 'number_of' element...

          // Reset list name
          free(currentListName);
          currentListName = NULL;
        }
      } else {
        currentListIndex = 1; // the index to be read next!
        // Allocate memory for storing list values (values will be converted later)
        currentListValues = malloc(currentListTotalNumber * sizeof(PIOSTRING));
        if (currentListValues == NULL) {
          perror("Error");
          return 1;
        }
      }

      // Update line counter
      currentLine++;
      continue;
    }

    // In case of a simple parameter
    if (sroll_updateParam(param, name, &value, 0) != 0) {
      return 1;
    }

    // Update line counter
    currentLine++;
  }
  
  //fprintf(stderr, "[DEBUG] End of parsing!\n");

  // Make some check

  // - Check that if we were reading list we read all elements otherwise print error msg.
  if (currentListName != NULL) {
    fprintf(stderr, "ERROR: missing some elements definition for parameter '%s'\n", currentListName);
    return 1;
  }

  // - All mandatory param must have been read! (see 'mandatory' and 'found')
  // Loop on all param def
  int i;
  for (i = 0; i < sroll_paramDef_list_size; i++) {
    if (sroll_paramDef_list[i].mandatory && (!sroll_paramDef_list[i].found)) {
      fprintf(stderr, "ERROR: Missing mandatory parameter '%s'\n", sroll_paramDef_list[i].name);
      return 1;
    }
  }

  //fprintf(stderr, "[DEBUG] Parameter file successfully parsed!\n");

  return 0;
}

*/
