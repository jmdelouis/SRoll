/******************************************************************************
 * "troll_parLoader.c"
 * 
 * This file has been generated by the ParLoader.
 *
 * This file is able to read a text parameter file (key=value) and load the
 * corresponding content to the specified structure.
 *
 * author:  Christan Madsen
 * date:    2015-04-03 (initial)
 * version: BETA
 *****************************************************************************/

#include <stdbool.h>
#include <stdlib.h>
#include <ctype.h>
#include <errno.h>
#include <string.h>
#include <Python.h>

#include "troll_parLoader.h"
#include "no_dmc_util.h" // Make use of several utils from the NO_DMC_LIB
//#include "no_dmc_debug.h"


// *** START INCLUDE GUARD ****************************************************
// The following is common to all parLoader 'instance'.

#ifndef _PARLOADER_C_GUARD
#define _PARLOADER_C_GUARD


// TODO to see if need to be set as PIOSTRING MAX LENGTH...
#define MAX_LINE_LENGTH 256

// This is the prefix used in parameter file to indicate the list number element
#define PARAM_PREFIX_LIST "number_of_"


// This structure allow to store parameters information
typedef struct {
  char *name;     // name of the parameter
  bool isList;    // 'false' for standard and 'true' for list
  bool mandatory; // 'true' if param presence is mandatory, 'false' otherwise. Note that in case of 'false' we have to update the flag value.
  bool found;     // to remember if we found the param
//  char *type;     // data type of the parameter : will be used for convertion from string to value. Type can be any of those listed in no_dmc_piolib_type_def.h
} paramDef;


//plip
/* ---------------------------------------------------------------------------------*/
int getListSize_old(PyObject * params,char * name){
  /* Function that return the size of list via list name */
  //name = "number_of_"+name
  //name = strcat("number_of_",name);
  int sizeNewName = strlen(PARAM_PREFIX_LIST)+ strlen( name ) + 1;
  char * newName = (char *) malloc( sizeNewName );

  strcpy(newName,PARAM_PREFIX_LIST);
  strcat(newName,name);

  int tmp_value = (int) PyLong_AsLong(PyDict_GetItemString(params,newName));

  free(newName);

  return tmp_value;
}
/* ---------------------------------------------------------------------------------*/
int getListSize(PyObject * params,char * name){
  /* Function that return the size of list via list name */
  //name = "number_of_"+name
  //name = strcat("number_of_",name);

  int size;
  PyObject * tmp = PyDict_GetItemString(params,name);
  size=(int)PyList_Size(tmp);


  return size;
}

/* ---------------------------------------------------------------------------------*/
int testParam(PyObject * params,char * name){
 /* test if name is in parameters list with keywords form PyObject =>params
  Params needed :
    name = keyword
  */
  PyObject * tmp_value=PyDict_GetItemString(params,name);
  if(tmp_value == NULL) return 1;
  return 0;
}
/* ---------------------------------------------------------------------------------*/
void strip_ext(char *fname)
{
    char *end = fname + strlen(fname);

    while (end > fname && *end != '.') {
        --end;
    }

    if (end > fname) {
        *end = '\0';
    }
}
/* ---------------------------------------------------------------------------------*/
PyObject * load_PyParams(char* path){
    /* Load python parameters form file gived in parameters path */    

    // init variables
    PyObject *pName, *pModule, *pDict, *pFunc;
    PyObject * params;


    // Initialize the Python Interpreter
    Py_Initialize();

    strip_ext(path);
    
    //add current path to python
    PyRun_SimpleString("import sys");
    PyRun_SimpleString("import os");
    PyRun_SimpleString("sys.path.append(os.getcwd())");

    // Build the name object
    pName = PyUnicode_FromString(path);
    
    // Load the module object
    pModule = PyImport_Import(pName);

    if ((pModule = PyImport_Import(pName)) == NULL) {
      fprintf(stderr,"Error: PyImport_Import\n");
      exit(0);
    }
 
    // pDict is a borrowed reference 
    pDict = PyModule_GetDict(pModule);

    // pFunc is also a borrowed reference 
    pFunc = PyDict_GetItemString(pDict, "main");

    if (PyCallable_Check(pFunc)){
        params = PyObject_CallObject(pFunc, NULL);
        
    }else{
        PyErr_Print();
        exit(0);
    }

    
 return params;
  
}
/* ---------------------------------------------------------------------------------*/
PyObject * getParam(PyObject * params,char * pName){
  /* get parameters with keywords form PyObject =>params 
  Params needed : 
    pName = keyword
  */ 
  
  PyObject * tmp_value=PyDict_GetItemString(params,pName);
  
  return tmp_value;

}
/* ---------------------------------------------------------------------------------*/
PyObject * getItemParam(PyObject * params,char * pName,int index){
  /* get item from parameter with keywords and index form PyObject =>params 
  Params needed : 
    pName = keyword
    index = index of the return param
   */  

  PyObject * tmp_value=PyDict_GetItemString(params,pName);

  tmp_value =PyList_GetItem(tmp_value,index);
  return tmp_value;

}
/* ---------------------------------------------------------------------------------*/



/**
 * Extract PIODOUBLE from the specified string value.
 */
PIODOUBLE myRead_PIODOUBLE(PIOSTRING value) {
  char *endptr;
  PIODOUBLE tmpval;
  
  tmpval = strtod(value, &endptr);

  // Ensure that all chars are converted to value, otherwise act like if it was an error.
  if (*endptr != '\0') {
    errno = EILSEQ;
  }

  return tmpval;
}

/**
 * Extract PIOLONG from the specified string value.
 */
PIOLONG myRead_PIOLONG(PIOSTRING value) {
  char *endptr;
  PIOLONG tmpval;
  
  tmpval = strtol(value, &endptr, 10);

  // Ensure that all chars are converted to value, otherwise act like if it was an error.
  if (*endptr != '\0') {
    errno = EILSEQ;
  }

  return tmpval;
}

/**
 * Extract PIOFLOAT from the specified string value.
 */
PIOFLOAT myRead_PIOFLOAT(PIOSTRING value) {
  char *endptr;
  PIOFLOAT tmpval;

  tmpval = strtof(value, &endptr);

  // Ensure that all chars are converted to value, otherwise act like if it was an error.
  if (*endptr != '\0') {
    errno = EILSEQ;
  }

  return tmpval;
}

/**
 * Extract PIOINT from the specified string value.
 */
PIOINT myRead_PIOINT(PIOSTRING value) {
  char *endptr;
  PIOINT tmpval;

  tmpval = strtol(value, &endptr, 10);

  // Ensure that all chars are converted to value, otherwise act like if it was an error.
  if (*endptr != '\0') {
    errno = EILSEQ;
  }

  return tmpval;
}

// Not that there is no myRead_PIOSTRING() since the conversion is unecessary!

/**
 * Allow to retrieve the corresponding paramDef (if any) regarding the name pass in arg.
 */
paramDef *getParamDef(char *name, paramDef paramDef_list[], int paramDef_list_size) {

  int i;
  for (i = 0; i < paramDef_list_size; i++) {
    if (strcmp(name, paramDef_list[i].name) == 0) {
      return &paramDef_list[i];
    }
  }
  
  fprintf(stderr, "ERROR: Invalid parameter '%s': not defined in struct header file!\n", name);
  return NULL;
}

#endif
// *** END INCLUDE GUARD ******************************************************


// Auto generated by the python script
paramDef troll_paramDef_list[] = {
  {"BeginRing", false, true, false},
  {"EndRing", false, true, false},
  {"ADDPOL", false, false, false},
  {"Calibration", true, true, false},
  {"seuilcond", false, true, false},
  {"NEP", true, true, false},
  {"Monop", true, true, false},
  {"bolomask", true, true, false},
  {"DOCNN", true, false, false},
  {"CNN_CORE", false, false, false},
  {"SEED", true, true, false},
  {"OUT_NOPOL", true, true, false},
  {"SUB_HPRCOEF", true, true, false},
  {"SAVEINTMAP", false, true, false},
  {"CNN_LEARN_PARAM", false, false, false},
  {"CNN_TMPID", false, false, false},
  {"BUILDTF", false, false, false},
  {"TEMPLATE_NSIDE", false, false, false},
  {"RSTEP", false, true, false},
  {"GAINSTEP", false, true, false},
  {"Nside", false, true, false},
  {"do_foscat", true, true, false},
  {"do_templates", true, true, false},
  {"NITT", false, true, false},
  {"N_IN_ITT", false, true, false},
  {"S_IN_ITT", false, true, false},
  {"NADU", true, true, false},
  {"NADUSTEP", true, true, false},
  {"in_template_map", true, false, false},
  {"number_val", false, true, false},
  {"beg_surv", true, true, false},
  {"end_surv", true, true, false},
  {"name_surv", true, true, false},
  {"do_mean", true, true, false},
  {"val_mean", true, true, false},
  {"w_mean", true, true, false},
  {"UNSEEN", false, true, false},
  {"projection", false, false, false},
  {"NORM_GAIN", false, true, false},
  {"REMOVE_CAL", false, true, false},
  {"Signal", true, false, false},
  {"External", true, false, false},
  {"rgcnn", true, false, false},
  {"invgi", true, false, false},
  {"Sub_HPR", true, false, false},
  {"SparseFunc", false, false, false},
  {"DiagFunc", false, false, false},
  {"External_MAP", true, false, false},
  {"Ptg", true, false, false},
  {"Hit", true, false, false},
  {"Badring", true, false, false},
  {"VarGain", true, false, false},
  {"Mask", false, false, false},
  {"Out_MAP", true, false, false},
  {"Out_VEC", true, false, false},
  {"verbose", false, false, false},
  {"do_offset", false, false, false},
  {"dmc_output_path", false, false, false},
  {"dmc_error_path", false, false, false},
  {"stim_paramfiles", true, false, false},
  {"MAPRINGS", true, false, false},
  {"ADDDIP", false, false, false},
  {"addHPR_name", true, false, false},
  {"addHPR_factor", true, false, false},
  {"addHPR_watts", true, false, false},
  {"delta_psi", true, false, false},
  {"MAP_CNN", false, false, false},
  {"INST_CNN", false, false, false},
};
int troll_paramDef_list_size = 68;



/**
 * Allow to update (ie. store) the parameter value(s) in the structure.
 *
 * @param list_size the size of the list (if any) otherwise the value is ignored.
 */
int troll_updateParam(troll_parContent *param, char *name, PIOSTRING *value, PIOLONG list_size) {
  //fprintf(stderr, "[DEBUG] updateParam() name = '%s'   value = '%s' list_size = "PIOLONG_FMT"\n", name, *value, list_size);

  // Retrieve our inner param def
  paramDef *currentParamDef = getParamDef(name, troll_paramDef_list, troll_paramDef_list_size);
  if (currentParamDef == NULL) {
    //fprintf(stderr, "ERROR: \n", name);
    return 3;
  }
  // Prevent redefinition
  if (currentParamDef->found) {
    fprintf(stderr, "ERROR: param '%s' already defined!\n", name);
    return 4;
  }
  // Mark the param as found
  currentParamDef->found = true;


  // Auto gen by python script
  // Copy into correct entry in parameters struct
  if (strcmp(name, "BeginRing") == 0) {
    errno = 0;
    param->BeginRing = myRead_PIOLONG(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'BeginRing': Unable to convert value '%s' to target type %s\n", *value, "PIOLONG");
      return 1;
    }
  }
  else if (strcmp(name, "EndRing") == 0) {
    errno = 0;
    param->EndRing = myRead_PIOLONG(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'EndRing': Unable to convert value '%s' to target type %s\n", *value, "PIOLONG");
      return 1;
    }
  }
  else if (strcmp(name, "ADDPOL") == 0) {
    param->flag_ADDPOL = _PAR_TRUE;
    strcpy(param->ADDPOL, *value);
  }
  else if (strcmp(name, "Calibration") == 0) {
    param->n_Calibration = list_size;
    param->Calibration = malloc(list_size * sizeof(PIODOUBLE));
    if (param->Calibration == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->Calibration[i] = myRead_PIODOUBLE(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'Calibration': Unable to convert value '%s' to target type %s\n", value[i], "PIODOUBLE");
        return 1;
      }
    }
  }
  else if (strcmp(name, "seuilcond") == 0) {
    errno = 0;
    param->seuilcond = myRead_PIODOUBLE(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'seuilcond': Unable to convert value '%s' to target type %s\n", *value, "PIODOUBLE");
      return 1;
    }
  }
  else if (strcmp(name, "NEP") == 0) {
    param->n_NEP = list_size;
    param->NEP = malloc(list_size * sizeof(PIODOUBLE));
    if (param->NEP == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->NEP[i] = myRead_PIODOUBLE(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'NEP': Unable to convert value '%s' to target type %s\n", value[i], "PIODOUBLE");
        return 1;
      }
    }
  }
  else if (strcmp(name, "Monop") == 0) {
    param->n_Monop = list_size;
    param->Monop = malloc(list_size * sizeof(PIODOUBLE));
    if (param->Monop == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->Monop[i] = myRead_PIODOUBLE(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'Monop': Unable to convert value '%s' to target type %s\n", value[i], "PIODOUBLE");
        return 1;
      }
    }
  }
  else if (strcmp(name, "bolomask") == 0) {
    param->n_bolomask = list_size;
    param->bolomask = malloc(list_size * sizeof(PIOINT));
    if (param->bolomask == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->bolomask[i] = myRead_PIOINT(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'bolomask': Unable to convert value '%s' to target type %s\n", value[i], "PIOINT");
        return 1;
      }
    }
  }
  else if (strcmp(name, "DOCNN") == 0) {
    param->flag_DOCNN = _PAR_TRUE;
    param->n_DOCNN = list_size;
    param->DOCNN = malloc(list_size * sizeof(PIOINT));
    if (param->DOCNN == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->DOCNN[i] = myRead_PIOINT(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'DOCNN': Unable to convert value '%s' to target type %s\n", value[i], "PIOINT");
        return 1;
      }
    }
  }
  else if (strcmp(name, "CNN_CORE") == 0) {
    param->flag_CNN_CORE = _PAR_TRUE;
    errno = 0;
    param->CNN_CORE = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'CNN_CORE': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "SEED") == 0) {
    param->n_SEED = list_size;
    param->SEED = malloc(list_size * sizeof(PIOINT));
    if (param->SEED == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->SEED[i] = myRead_PIOINT(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'SEED': Unable to convert value '%s' to target type %s\n", value[i], "PIOINT");
        return 1;
      }
    }
  }
  else if (strcmp(name, "OUT_NOPOL") == 0) {
    param->n_OUT_NOPOL = list_size;
    param->OUT_NOPOL = malloc(list_size * sizeof(PIOINT));
    if (param->OUT_NOPOL == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->OUT_NOPOL[i] = myRead_PIOINT(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'OUT_NOPOL': Unable to convert value '%s' to target type %s\n", value[i], "PIOINT");
        return 1;
      }
    }
  }
  else if (strcmp(name, "SUB_HPRCOEF") == 0) {
    param->n_SUB_HPRCOEF = list_size;
    param->SUB_HPRCOEF = malloc(list_size * sizeof(PIOFLOAT));
    if (param->SUB_HPRCOEF == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->SUB_HPRCOEF[i] = myRead_PIOFLOAT(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'SUB_HPRCOEF': Unable to convert value '%s' to target type %s\n", value[i], "PIOFLOAT");
        return 1;
      }
    }
  }
  else if (strcmp(name, "SAVEINTMAP") == 0) {
    errno = 0;
    param->SAVEINTMAP = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'SAVEINTMAP': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "CNN_LEARN_PARAM") == 0) {
    param->flag_CNN_LEARN_PARAM = _PAR_TRUE;
    errno = 0;
    param->CNN_LEARN_PARAM = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'CNN_LEARN_PARAM': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "CNN_TMPID") == 0) {
    param->flag_CNN_TMPID = _PAR_TRUE;
    strcpy(param->CNN_TMPID, *value);
  }
  else if (strcmp(name, "BUILDTF") == 0) {
    param->flag_BUILDTF = _PAR_TRUE;
    errno = 0;
    param->BUILDTF = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'BUILDTF': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "TEMPLATE_NSIDE") == 0) {
    param->flag_TEMPLATE_NSIDE = _PAR_TRUE;
    errno = 0;
    param->TEMPLATE_NSIDE = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'TEMPLATE_NSIDE': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "RSTEP") == 0) {
    errno = 0;
    param->RSTEP = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'RSTEP': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "GAINSTEP") == 0) {
    errno = 0;
    param->GAINSTEP = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'GAINSTEP': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "Nside") == 0) {
    errno = 0;
    param->Nside = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'Nside': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "do_foscat") == 0) {
    param->n_do_foscat = list_size;
    param->do_foscat = malloc(list_size * sizeof(PIOINT));
    if (param->do_foscat == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->do_foscat[i] = myRead_PIOINT(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'do_foscat': Unable to convert value '%s' to target type %s\n", value[i], "PIOINT");
        return 1;
      }
    }
  }
  else if (strcmp(name, "do_templates") == 0) {
    param->n_do_templates = list_size;
    param->do_templates = malloc(list_size * sizeof(PIOINT));
    if (param->do_templates == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->do_templates[i] = myRead_PIOINT(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'do_templates': Unable to convert value '%s' to target type %s\n", value[i], "PIOINT");
        return 1;
      }
    }
  }
  else if (strcmp(name, "NITT") == 0) {
    errno = 0;
    param->NITT = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'NITT': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "N_IN_ITT") == 0) {
    errno = 0;
    param->N_IN_ITT = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'N_IN_ITT': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "S_IN_ITT") == 0) {
    errno = 0;
    param->S_IN_ITT = myRead_PIODOUBLE(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'S_IN_ITT': Unable to convert value '%s' to target type %s\n", *value, "PIODOUBLE");
      return 1;
    }
  }
  else if (strcmp(name, "NADU") == 0) {
    param->n_NADU = list_size;
    param->NADU = malloc(list_size * sizeof(PIOINT));
    if (param->NADU == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->NADU[i] = myRead_PIOINT(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'NADU': Unable to convert value '%s' to target type %s\n", value[i], "PIOINT");
        return 1;
      }
    }
  }
  else if (strcmp(name, "NADUSTEP") == 0) {
    param->n_NADUSTEP = list_size;
    param->NADUSTEP = malloc(list_size * sizeof(PIOINT));
    if (param->NADUSTEP == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->NADUSTEP[i] = myRead_PIOINT(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'NADUSTEP': Unable to convert value '%s' to target type %s\n", value[i], "PIOINT");
        return 1;
      }
    }
  }
  else if (strcmp(name, "in_template_map") == 0) {
    param->flag_in_template_map = _PAR_TRUE;
    param->n_in_template_map = list_size;
    param->in_template_map = malloc(list_size * sizeof(PIOSTRING));
    if (param->in_template_map == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->in_template_map[i], value[i]);
    }
  }
  else if (strcmp(name, "number_val") == 0) {
    errno = 0;
    param->number_val = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'number_val': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "beg_surv") == 0) {
    param->n_beg_surv = list_size;
    param->beg_surv = malloc(list_size * sizeof(PIOLONG));
    if (param->beg_surv == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->beg_surv[i] = myRead_PIOLONG(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'beg_surv': Unable to convert value '%s' to target type %s\n", value[i], "PIOLONG");
        return 1;
      }
    }
  }
  else if (strcmp(name, "end_surv") == 0) {
    param->n_end_surv = list_size;
    param->end_surv = malloc(list_size * sizeof(PIOLONG));
    if (param->end_surv == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->end_surv[i] = myRead_PIOLONG(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'end_surv': Unable to convert value '%s' to target type %s\n", value[i], "PIOLONG");
        return 1;
      }
    }
  }
  else if (strcmp(name, "name_surv") == 0) {
    param->n_name_surv = list_size;
    param->name_surv = malloc(list_size * sizeof(PIOSTRING));
    if (param->name_surv == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->name_surv[i], value[i]);
    }
  }
  else if (strcmp(name, "do_mean") == 0) {
    param->n_do_mean = list_size;
    param->do_mean = malloc(list_size * sizeof(PIODOUBLE));
    if (param->do_mean == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->do_mean[i] = myRead_PIODOUBLE(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'do_mean': Unable to convert value '%s' to target type %s\n", value[i], "PIODOUBLE");
        return 1;
      }
    }
  }
  else if (strcmp(name, "val_mean") == 0) {
    param->n_val_mean = list_size;
    param->val_mean = malloc(list_size * sizeof(PIODOUBLE));
    if (param->val_mean == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->val_mean[i] = myRead_PIODOUBLE(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'val_mean': Unable to convert value '%s' to target type %s\n", value[i], "PIODOUBLE");
        return 1;
      }
    }
  }
  else if (strcmp(name, "w_mean") == 0) {
    param->n_w_mean = list_size;
    param->w_mean = malloc(list_size * sizeof(PIODOUBLE));
    if (param->w_mean == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->w_mean[i] = myRead_PIODOUBLE(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'w_mean': Unable to convert value '%s' to target type %s\n", value[i], "PIODOUBLE");
        return 1;
      }
    }
  }
  else if (strcmp(name, "UNSEEN") == 0) {
    errno = 0;
    param->UNSEEN = myRead_PIODOUBLE(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'UNSEEN': Unable to convert value '%s' to target type %s\n", *value, "PIODOUBLE");
      return 1;
    }
  }
  else if (strcmp(name, "projection") == 0) {
    param->flag_projection = _PAR_TRUE;
    strcpy(param->projection, *value);
  }
  else if (strcmp(name, "NORM_GAIN") == 0) {
    errno = 0;
    param->NORM_GAIN = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'NORM_GAIN': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "REMOVE_CAL") == 0) {
    errno = 0;
    param->REMOVE_CAL = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'REMOVE_CAL': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "Signal") == 0) {
    param->flag_Signal = _PAR_TRUE;
    param->n_Signal = list_size;
    param->Signal = malloc(list_size * sizeof(PIOSTRING));
    if (param->Signal == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->Signal[i], value[i]);
    }
  }
  else if (strcmp(name, "External") == 0) {
    param->flag_External = _PAR_TRUE;
    param->n_External = list_size;
    param->External = malloc(list_size * sizeof(PIOSTRING));
    if (param->External == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->External[i], value[i]);
    }
  }
  else if (strcmp(name, "rgcnn") == 0) {
    param->flag_rgcnn = _PAR_TRUE;
    param->n_rgcnn = list_size;
    param->rgcnn = malloc(list_size * sizeof(PIOSTRING));
    if (param->rgcnn == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->rgcnn[i], value[i]);
    }
  }
  else if (strcmp(name, "invgi") == 0) {
    param->flag_invgi = _PAR_TRUE;
    param->n_invgi = list_size;
    param->invgi = malloc(list_size * sizeof(PIOSTRING));
    if (param->invgi == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->invgi[i], value[i]);
    }
  }
  else if (strcmp(name, "Sub_HPR") == 0) {
    param->flag_Sub_HPR = _PAR_TRUE;
    param->n_Sub_HPR = list_size;
    param->Sub_HPR = malloc(list_size * sizeof(PIOSTRING));
    if (param->Sub_HPR == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->Sub_HPR[i], value[i]);
    }
  }
  else if (strcmp(name, "SparseFunc") == 0) {
    param->flag_SparseFunc = _PAR_TRUE;
    strcpy(param->SparseFunc, *value);
  }
  else if (strcmp(name, "DiagFunc") == 0) {
    param->flag_DiagFunc = _PAR_TRUE;
    strcpy(param->DiagFunc, *value);
  }
  else if (strcmp(name, "External_MAP") == 0) {
    param->flag_External_MAP = _PAR_TRUE;
    param->n_External_MAP = list_size;
    param->External_MAP = malloc(list_size * sizeof(PIOSTRING));
    if (param->External_MAP == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->External_MAP[i], value[i]);
    }
  }
  else if (strcmp(name, "Ptg") == 0) {
    param->flag_Ptg = _PAR_TRUE;
    param->n_Ptg = list_size;
    param->Ptg = malloc(list_size * sizeof(PIOSTRING));
    if (param->Ptg == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->Ptg[i], value[i]);
    }
  }
  else if (strcmp(name, "Hit") == 0) {
    param->flag_Hit = _PAR_TRUE;
    param->n_Hit = list_size;
    param->Hit = malloc(list_size * sizeof(PIOSTRING));
    if (param->Hit == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->Hit[i], value[i]);
    }
  }
  else if (strcmp(name, "Badring") == 0) {
    param->flag_Badring = _PAR_TRUE;
    param->n_Badring = list_size;
    param->Badring = malloc(list_size * sizeof(PIOSTRING));
    if (param->Badring == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->Badring[i], value[i]);
    }
  }
  else if (strcmp(name, "VarGain") == 0) {
    param->flag_VarGain = _PAR_TRUE;
    param->n_VarGain = list_size;
    param->VarGain = malloc(list_size * sizeof(PIOSTRING));
    if (param->VarGain == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->VarGain[i], value[i]);
    }
  }
  else if (strcmp(name, "Mask") == 0) {
    param->flag_Mask = _PAR_TRUE;
    strcpy(param->Mask, *value);
  }
  else if (strcmp(name, "Out_MAP") == 0) {
    param->flag_Out_MAP = _PAR_TRUE;
    param->n_Out_MAP = list_size;
    param->Out_MAP = malloc(list_size * sizeof(PIOSTRING));
    if (param->Out_MAP == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->Out_MAP[i], value[i]);
    }
  }
  else if (strcmp(name, "Out_VEC") == 0) {
    param->flag_Out_VEC = _PAR_TRUE;
    param->n_Out_VEC = list_size;
    param->Out_VEC = malloc(list_size * sizeof(PIOSTRING));
    if (param->Out_VEC == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->Out_VEC[i], value[i]);
    }
  }
  else if (strcmp(name, "verbose") == 0) {
    param->flag_verbose = _PAR_TRUE;
    errno = 0;
    param->verbose = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'verbose': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "do_offset") == 0) {
    param->flag_do_offset = _PAR_TRUE;
    errno = 0;
    param->do_offset = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'do_offset': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "dmc_output_path") == 0) {
    param->flag_dmc_output_path = _PAR_TRUE;
    strcpy(param->dmc_output_path, *value);
  }
  else if (strcmp(name, "dmc_error_path") == 0) {
    param->flag_dmc_error_path = _PAR_TRUE;
    strcpy(param->dmc_error_path, *value);
  }
  else if (strcmp(name, "stim_paramfiles") == 0) {
    param->flag_stim_paramfiles = _PAR_TRUE;
    param->n_stim_paramfiles = list_size;
    param->stim_paramfiles = malloc(list_size * sizeof(PIOSTRING));
    if (param->stim_paramfiles == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->stim_paramfiles[i], value[i]);
    }
  }
  else if (strcmp(name, "MAPRINGS") == 0) {
    param->flag_MAPRINGS = _PAR_TRUE;
    param->n_MAPRINGS = list_size;
    param->MAPRINGS = malloc(list_size * sizeof(PIOINT));
    if (param->MAPRINGS == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->MAPRINGS[i] = myRead_PIOINT(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'MAPRINGS': Unable to convert value '%s' to target type %s\n", value[i], "PIOINT");
        return 1;
      }
    }
  }
  else if (strcmp(name, "ADDDIP") == 0) {
    param->flag_ADDDIP = _PAR_TRUE;
    errno = 0;
    param->ADDDIP = myRead_PIOINT(*value);
    if (errno != 0) {
      fprintf(stderr, "ERROR: 'ADDDIP': Unable to convert value '%s' to target type %s\n", *value, "PIOINT");
      return 1;
    }
  }
  else if (strcmp(name, "addHPR_name") == 0) {
    param->flag_addHPR_name = _PAR_TRUE;
    param->n_addHPR_name = list_size;
    param->addHPR_name = malloc(list_size * sizeof(PIOSTRING));
    if (param->addHPR_name == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      strcpy(param->addHPR_name[i], value[i]);
    }
  }
  else if (strcmp(name, "addHPR_factor") == 0) {
    param->flag_addHPR_factor = _PAR_TRUE;
    param->n_addHPR_factor = list_size;
    param->addHPR_factor = malloc(list_size * sizeof(PIOFLOAT));
    if (param->addHPR_factor == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->addHPR_factor[i] = myRead_PIOFLOAT(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'addHPR_factor': Unable to convert value '%s' to target type %s\n", value[i], "PIOFLOAT");
        return 1;
      }
    }
  }
  else if (strcmp(name, "addHPR_watts") == 0) {
    param->flag_addHPR_watts = _PAR_TRUE;
    param->n_addHPR_watts = list_size;
    param->addHPR_watts = malloc(list_size * sizeof(PIOINT));
    if (param->addHPR_watts == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->addHPR_watts[i] = myRead_PIOINT(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'addHPR_watts': Unable to convert value '%s' to target type %s\n", value[i], "PIOINT");
        return 1;
      }
    }
  }
  else if (strcmp(name, "delta_psi") == 0) {
    param->flag_delta_psi = _PAR_TRUE;
    param->n_delta_psi = list_size;
    param->delta_psi = malloc(list_size * sizeof(PIOFLOAT));
    if (param->delta_psi == NULL) {
      perror("Error");
      return 1;
    }
    int i;
    for (i = 0; i < list_size; i++) {
      errno = 0;
      param->delta_psi[i] = myRead_PIOFLOAT(value[i]);
      if (errno != 0) {
        fprintf(stderr, "ERROR: 'delta_psi': Unable to convert value '%s' to target type %s\n", value[i], "PIOFLOAT");
        return 1;
      }
    }
  }
  else if (strcmp(name, "MAP_CNN") == 0) {
    param->flag_MAP_CNN = _PAR_TRUE;
    strcpy(param->MAP_CNN, *value);
  }
  else if (strcmp(name, "INST_CNN") == 0) {
    param->flag_INST_CNN = _PAR_TRUE;
    strcpy(param->INST_CNN, *value);
  }
  else {
    fprintf(stderr, "ERROR: %s: Unknown param name!\n", name);
    return 1;
  }



  return 0;
}


PyObject *troll_readParam(troll_parContent *param, char *filename) {
  // Parse the parameter file: read each line and update info in structure
  // if we encounter an error stop the process or print a warning depending of the severity.

  // check MPI rank
  char* pEnv;
  int mpi_rank;
  pEnv = getenv( "OMPI_COMM_WORLD_RANK"); // openmpi
  if (pEnv == NULL) {
    pEnv = getenv( "SLURM_PROCID"); // http://slurm.schedmd.com/sbatch.html
  }
  if (pEnv == NULL) {
    pEnv = getenv( "PMI_RANK"); // datarmor mpicc
  }
  if (pEnv == NULL) {
    mpi_rank = 0;
  } else {
    mpi_rank = atoi( pEnv);
  }

  if (mpi_rank == 0) {
    fprintf( stderr, "\n\ntroll_readParam() from file \"%s\"\n",filename);
  }

  // Init the structure to ensure all flag are set to false by default
  memset(param, 0, sizeof(troll_parContent));

  // Open the param file
  PyObject * pyParams = load_PyParams(filename);
  if (pyParams == NULL) {
    fprintf(stderr, "ERROR while trying to open parameter file: '%s'\n", filename);
    PyErr_Print();
    perror("Error");
    exit(-1);
    return NULL;
  }

  // Init the internal structure allowing to know if a parameter has already appeared.
  for (int i=0; i < troll_paramDef_list_size; i++) {
    troll_paramDef_list[i].found = false;
  }

  // Init the list values
  PIOLONG currentListIndex = 0; // the index of next element to be read
  PIOSTRING *currentListValues = NULL; // The array of PIOSTRING to store all values of the list
  char value[MAX_LINE_LENGTH];

  for(int i =0;i<troll_paramDef_list_size;i++){
    int flag_parsing = 0; 
    currentListIndex = 0;

    int valid_param = testParam(pyParams,troll_paramDef_list[i].name);
    
    //if params is in pyParams
    if(valid_param == 0){     
      char * name = troll_paramDef_list[i].name;
      //If list of params
      
      if(troll_paramDef_list[i].isList){    
        int ListSize = getListSize(pyParams,name);
	      //If list not null
	      if(ListSize!=-1) {
	        //create list values params
          currentListValues = malloc(ListSize * sizeof(PIOSTRING));

	        while(currentListIndex!=ListSize && flag_parsing == 0){
              PyObject * pyValue =getItemParam(pyParams,troll_paramDef_list[i].name,currentListIndex);  
              if(pyValue != NULL){
                //PIOSTRING * value = PyUnicode_AsUTF8(PyObject_Str(pyValue));
		//strncpy(value,PyUnicode_AsUTF8(PyObject_Str(pyValue)),MAX_LINE_LENGTH);
       
                #if PY_MAJOR_VERSION >= 3
		strncpy(value,PyUnicode_AsUTF8(PyObject_Str(pyValue)),MAX_LINE_LENGTH-1);
		#else
		strncpy(value,PyString_AsString(PyObject_Str(pyValue)),MAX_LINE_LENGTH-1);
		#endif
		
		// Store the list value
                strcpy(currentListValues[currentListIndex], value); // -1 since array is 0 indexed!
                currentListIndex++;		            
              }else{
                flag_parsing =1;
              }
            }
	 
            // Save List parameter to param structure
            troll_updateParam(param,name,currentListValues,ListSize);
          }
      }else{
        // Save simple parameters to param structure
        PyObject * pyValue =getParam(pyParams,troll_paramDef_list[i].name);
        if(pyValue != NULL){
          PIOSTRING *value = (PIOSTRING *) PyUnicode_AsUTF8(PyObject_Str(pyValue));
          troll_updateParam(param,name,value,0);
        }
      }
    }
  }    
  return pyParams;
}



/*

int troll_readParam(troll_parContent *param, char *filename) {

  // Parse the parameter file: read each line and update info in structure
  // if we encounter an error stop the process or print a warning depending of the severity.

  // check MPI rank
  char* pEnv;
  int mpi_rank;
  pEnv = getenv( "OMPI_COMM_WORLD_RANK"); // openmpi
  if (pEnv == NULL) {
    pEnv = getenv( "SLURM_PROCID"); // http://slurm.schedmd.com/sbatch.html
  }
  if (pEnv == NULL) {
    pEnv = getenv( "PMI_RANK"); // datarmor mpicc
  }
  if (pEnv == NULL) {
    mpi_rank = 0;
  } else {
    mpi_rank = atoi( pEnv);
  }

  if (mpi_rank == 0) {
    fprintf( stderr, "\n\ntroll_readParam() from file \"%s\"\n", filename);
  }

  // Init the structure to ensure all flag are set to false by default
  memset(param, 0, sizeof(troll_parContent));

  // Open the param file
  FILE *fp = fopen(filename, "r");
  if (fp == NULL) {
    fprintf(stderr, "ERROR while trying to open parameter file: '%s'\n", filename);
    perror("Error");
    return 1;
  }

  // Init the internal structure allowing to know if a parameter has already appeared.
  for (int i=0; i < troll_paramDef_list_size; i++) {
    troll_paramDef_list[i].found = false;
  }

  // Init the list values
  char *currentListName = NULL; // The list name (= the parameter name for the list)
  PIOLONG currentListTotalNumber = 0; // The total number of element in the list
  PIOLONG currentListIndex = 0; // the index of next element to be read
  PIOSTRING *currentListValues = NULL; // The array of PIOSTRING to store all values of the list

  // Init of parsing values
  char *s;
  char buff[MAX_LINE_LENGTH];
  int currentLine = 1;

  // Loop on each line of the parameter file
  while (fgets(buff, sizeof buff, fp) != NULL) {
    //fprintf(stderr, "[DEBUG] *** line #%d: '%s'\nstrlen(buff)= %zd\n", currentLine, buff, strlen(buff));

    // Check that line is not too long!
    if (strlen(buff) == (MAX_LINE_LENGTH-1)) { // -1 since we do not count the last char '\0'
      // In log we specify MAX_LINE_LENGTH-3 since we remove the new line char and the '\0' and take one more char to be sure we don't exceed.
      fprintf(stderr, "ERROR parameter file: '%s' has its line #%d too long! (max is %d chars)\n", filename, currentLine, MAX_LINE_LENGTH-3);
      return 1;
    }

    int firstChar = 0;
    while (isspace(buff[firstChar])) {
      firstChar++;
    }
    // Skip blank lines and comments
    if ((firstChar == strlen(buff)) || buff[firstChar] == '\n' || buff[firstChar] == '#') {
      //fprintf(stderr, "[DEBUG] line %d is empty or comment\n", currentLine);
      // Update line counter
      currentLine++;
      continue;
    }

    // Parse name/value pair from line
    char name[MAX_LINE_LENGTH], value[MAX_LINE_LENGTH];
    s = strtok(buff, "=");
    if (s==NULL) {
      fprintf(stderr, "ERROR: Missing param affectation symbol '=' at line %d\n", currentLine);
      //fprintf(stderr, "[DEBUG] line: %s\n", buff);
      return 1;
    }
    else {
      s = trim(s);
      strncpy(name, s, MAX_LINE_LENGTH);
    }
    s = strtok (NULL, "=");
    if (s==NULL || strlen(trim(s)) == 0) {
      fprintf(stderr, "ERROR: Missing param value at line %d\n", currentLine);
      //fprintf(stderr, "[DEBUG] line: %s\n", buff);
      return 1;
    }
    else {
      s = trim(s);
      strncpy(value, s, MAX_LINE_LENGTH);
    }

    if (mpi_rank == 0) {
      fprintf( stderr, "%s: reading %s = %s\n", __FILE__, name, value);
    }

    // Check if we are in a list reading phase
    if (currentListName != NULL) {
      char list_elt_to_be_read[MAX_LINE_LENGTH]; // Allow to store the name of the expected parameter (in case of list)
      sprintf(list_elt_to_be_read, "%s"PIOLONG_FMT"", currentListName, currentListIndex);
      if (strcmp(name, list_elt_to_be_read) != 0) {
        fprintf(stderr, "ERROR: We were expecting list param '%s' at line %d, but found '%s'\n",
            list_elt_to_be_read, currentLine, name);
        return 1;
      }

      // Store the list value
      strcpy(currentListValues[currentListIndex-1], value); // -1 since array is 0 indexed!

      // Handle end of list
      if (currentListIndex == currentListTotalNumber) {
        // Save List to param structure
        if (troll_updateParam(param, currentListName, currentListValues, currentListTotalNumber) != 0) {
          free(currentListName);
          return 1;
        }
        // Reset list name
        free(currentListName);
        currentListName = NULL;
      } else {
        currentListIndex++;
      }
      // Update line counter
      currentLine++;
      continue;
    }

    // Handle special param prefix: PARAM_PREFIX_LIST ("number_of_")
    if (startsWith(name, PARAM_PREFIX_LIST) == 0) {
      //fprintf(stderr, "[DEBUG] we detect a list number prefix at line: %d\n", currentLine);
      // Update info with number of element to be read...
      // - Save the current list param name
      currentListName = strdupnodmc(name+strlen(PARAM_PREFIX_LIST));
      if (currentListName == NULL) {
        perror("Error");
        return 1;
      }
      //fprintf(stderr, "[DEBUG] list param name: '%s'\n", currentListName);

      // Retrieve our inner param def
      paramDef *currentParamDef = getParamDef(currentListName, troll_paramDef_list, troll_paramDef_list_size);
      if (currentParamDef == NULL) {
        fprintf(stderr, "ERROR (line #%d): 'number_of' parameter refer to an invalid element '%s'\n", currentLine, currentListName);
        return 1;
      }

      // Check that the "number_of" refered to an existing element of type list
      if (!currentParamDef->isList) {
        fprintf(stderr, "ERROR (line #%d): 'number_of' parameter refer to a none list element '%s'\n", currentLine, currentListName);
        return 1;
      }
      
      // - Update info about list
      errno = 0;
      currentListTotalNumber = myRead_PIOLONG(value);
      if (errno != 0) {
        fprintf(stderr, "ERROR (line #%d): Unable to convert value '%s' to target type %s\n", currentLine, value, "PIOLONG");
        //perror("Error");
        return 1;
      }
      //fprintf(stderr, "[DEBUG] list param total number: "PIOLONG_FMT"\n", currentListTotalNumber);

      // Check that "number_of" can't be negative
      if (currentListTotalNumber < 0) {
        fprintf(stderr, "ERROR (line #%d): 'number_of' parameter can't be negative!\n", currentLine);
        return 1;
      }

      // Check that if param is required, the "number_of" can't be 0
      if (currentListTotalNumber == 0) {
        // Retrieve mandatory bool
        bool mandatory = currentParamDef->mandatory;

        if (mandatory) {
          fprintf(stderr, "ERROR (line %d): 'number_of' parameter can't be 0 for the mandatory element '%s'!\n", currentLine, currentListName);
          return 1;
        } else {
          // In this case we expect no other parameters of this name!
          // We just "ignore" the 'number_of' element...

          // Reset list name
          free(currentListName);
          currentListName = NULL;
        }
      } else {
        currentListIndex = 1; // the index to be read next!
        // Allocate memory for storing list values (values will be converted later)
        currentListValues = malloc(currentListTotalNumber * sizeof(PIOSTRING));
        if (currentListValues == NULL) {
          perror("Error");
          return 1;
        }
      }

      // Update line counter
      currentLine++;
      continue;
    }

    // In case of a simple parameter
    if (troll_updateParam(param, name, &value, 0) != 0) {
      return 1;
    }

    // Update line counter
    currentLine++;
  }
  
  //fprintf(stderr, "[DEBUG] End of parsing!\n");

  // Make some check

  // - Check that if we were reading list we read all elements otherwise print error msg.
  if (currentListName != NULL) {
    fprintf(stderr, "ERROR: missing some elements definition for parameter '%s'\n", currentListName);
    return 1;
  }

  // - All mandatory param must have been read! (see 'mandatory' and 'found')
  // Loop on all param def
  int i;
  for (i = 0; i < troll_paramDef_list_size; i++) {
    if (troll_paramDef_list[i].mandatory && (!troll_paramDef_list[i].found)) {
      fprintf(stderr, "ERROR: Missing mandatory parameter '%s'\n", troll_paramDef_list[i].name);
      return 1;
    }
  }

  //fprintf(stderr, "[DEBUG] Parameter file successfully parsed!\n");

  return 0;
}

*/
